# Ответы к экзамену
---
## 1. Функции и механизмы ОС, появившиеся на этапе программ-диспетчеров, предшественников операционных систем.

* Сначала компьютеры работали на **архитектуре Фон Неймана**
![img](https://sun9-14.userapi.com/impg/IR2frlkgJ5lfBghMtuPjLp01tvIM7NC3LH1NzQ/7q7oM_iRaAI.jpg?size=1426x610&quality=96&proxy=1&sign=f68e6223db7a14e7240304535814190a&type=album)
  * Суть данной архитектуры заключалась в том, что **cpu** был связан с **ram**, **input**, **output** и **storage**.
  * Проблема **архитектуры Фон Неймана** заключалась в сложности параллельного выполнения программ, так как было сложно достичь синхронизации данных на входе и выходе

#### Задача - распараллеливать процессы, которые проходят через cpu
#### Решение - программа диспетчер
**Программы-диспетчеры** появились для автоматизации загрузки и линковки данных, которые писались под конкретную машину. Когда осознали, что многие части кода повторяются, решили отвести специально место в оперативной памяти для пакетов(библиотек), отсюда возникли задачи:

* автоматизировать линковку (связь приложений с ячейками памяти),

* оптимизировать взаимодействия с устройствами ввода/вывода.


### Задача - оптимизация взаимодействия с устройствами ввода вывода и хранения

* Все пути идут через процессор -> (**при архитектуре Фон Неймана**)
* Проблема - мало **ram** для хранения огромного количества данных, если временные данные хранить в **ram**
* Проблема - процессор при такой работе работает не рационально, потому что выполняет простые операции, которые не используют всю его мощь

##### Таким образом был придуман принципы распараллеливания процессов

При параллельном выполнении процессов возникают сложности:
* Хранилище не гарантирует нам быстрый доступ к данным, из-за этого мы не знаем, когда кончится операция ввода-вывода
* Основная проблема в том, что таким образом нам сложно синхронизировать параллельность разгрузки погрузки памяти
### Функции программ-диспетчеров
##### Спулинг
  * Взаимодействие с input/output/storage занимало очень много времени из-за однозадачности CPU. Распараллеливание будем совершать через простейший процессор - контроллер.
**Спулинг** (SPOOL, Simultaneous Peripheral Output On-Line) - процесс взаимодействия ram/storage через контроллер
  * POOL (спулинг) — спулинг это буферизация данных перед их обработкой
Контроллер сохранял в своих регистрах не только те данные, которые запрашивались, но и те, которые могут потребоваться в ближайшее время.
#### Прерывания
  * **Прерывание** (Interrupt) - специальный сигнал от контроллера к CPU сообщающий о некотором событии (наступлении события), прерывающий ход выполнения текущей программы и передающий управление обработчику прерываний.
  
#### Однопрограммная пакетная обработка
* __Пакет__ – совокупность программных модулей, обрабатываемых данных и конфигураций. 

---

## 2. Функции и механизмы ОС, появившиеся на этапе мультипрограммных операционных систем.

#### Задача: выполнять одновременно несколько задач

##### В чем необходимость ?

* Наши приложения обладают различным поведением, соответственно, они с разной нагрузкой воздействуют на CPU
* Появление псеводопараллельности:
  * Несмотря на то, что процессор "не простаивает", переключение между процессами будет занимать время.
![img](https://sun9-4.userapi.com/impg/fwwgGnoBHluGlrUrFiLw-IcEQYGM4DLb_Gox2Q/ZyDx1drTMmw.jpg?size=712x248&quality=96&proxy=1&sign=519c0d4d4b1a5a4f124ef5f8530f9a68&type=album)

### Функции
 * ##### 1 Задача - обеспечение времени разделения процессора
   * __Что нужно для разделения времени процессора?__
      * Есть 2 процесса. Будем чередовать их выполнение.
      * Как сделать переход ?
      * Нужно запомнить место, где процесс остановился (сохранить контекст процесса).
        * Сохранить значения регистров.
        * Загрузить данные в регистры для нового процесса **(это требует времени)**
    * __Как процессу остановить другой процесс?__
      * __Решение на аппаратном уровне (как контроллер для spooling'a)__
        * Добавили таймер, который через равные промежутки прерывает выполнение процессов.
        * Прерывание - это передача управления процессами диспетчеру прерывания
 * ##### 2 Задача - необходимо разделять память
      * __Virtual Memory__ - способ адресации, при котором каждой программе выделяется виртуальное пространство, адресуемое с нуля. ОС подменяет виртуальный адрес на реальный. Появляется задача защиты областей памяти.
 * ##### 3 Задача - обеспечение защиты программы от действия других программ (задача защиты областей памяти)
    * Надо защищать адресное пространство, т.к. в результате ошибки программиста, мы можем выйти за пределы адресного пространства, при записи туда, возникнет сбой.
    
    * __Механизм защиты памяти - аппаратное решение__

      * Он будет проверять права доступа для записи или чтения
      * Прерывание по защите памяти:
        * Простое решение - уничтожить процесс, которые пытается сделать что-то противозаконное
 
 * ##### 4 Задача - планирование выполнения программы
      * Каждый процесс считает, что он имеет полное адресное пространство, но физическая память ограничена, поэтому нужно планировать использование памяти процессами. ОС также должна решать когда и какой процесс будет выполняться, при каких условиях переключаться.     

 * ##### 5 Задача - задача по синхронизации
    * Нужны механизмы, которые обеспечат межпроцессорную синхронизацию
 * ##### 6 Задача - задача доступа к информации на внешнем хранилище
    * При мультипрограммности появляется проблема контролируемого доступа к данным в хранилище
    * нужно обеспечить очередь
    * Нужно правильно выбрать адреса в хранилище (__для ускорения линковки например__)
      * Можно хранить программы в библиотеке на хранилище и подгружать их (__нужна особая адресация__)
    * __Появляется механизм файлово - каталоговой системы__
      * Даем уникальные имена
      * Группируем их в директории
      * Выстраиваем иерархию между ними
      * Получаем контролируемый доступ к данным в хранилище

--- 
## 3. Функции и механизмы, появившиеся на этапах сетевых и мобильных (универсальных) операционных систем.

### сетевые операционные системы
* Проблемы
  * Много данных
  * Машины очень дорогие
  * Количество потребителей растет => возникает разделение машинного времени среди пользователей
  * Накладные расходы
  * Ввод и вывод - узкое место. Много программ, один оператор, который вводит программ в компьютер -> снижение эффективности использования компьютера
#### Решение - Удаленные терминалы
* Объединим входные и выходные устройства
* Звоним в вычислительный узел и просим что-то вычислить
* Появляется многотерминальная проблема
  * Безопасность - нет оператора, который контролирует ввод и вывод, можно внести вирус
    * Появляется механизм аутентификации и авторизации
    * Вводится понятие пользователя и пользовательский режим
* Появляется удаленное взаимодействие между различными вычислительными узлами
  * есть 2 города с машинами, появляется механизм по обмену данными между машинами
  * __Появляются распределенные операционные системы__

### открытые операционные системы
* Предпосылка
  * Проблема переносимости кода
  * Нужна ось, которая может запускаться на различных компьютерах
* Проблемы:
  * Нужна ось, которая сама по себе будет работать на языке высокого уровня
* Bella boretlis - великая компания
  * Они создают __Unix__ и __C__
  * В 1969 году выходит операционная система unix (__UNICS__), написанная на ассемблере
  * На следующем этапе эта команда разрабатывает язык би и unix переписывается под нее уже существующую версию
  * Выходит 3 редакция с компилятором си 
  * Выходит 4 редакция с ядром, написанным на си
  * Выходит 5 редакция, которая полностью написана на си
  * Таким образом появилась универсальная операционная система **Unix**

## Как появился Linux
* Появился проект GNU (__GNU NOT UNIX__)
  * Разрабатывают компилятор GCC
  * Разрабатываются утилиты и модули на Си
  * Нужно написать ядро
    * Студент Линукс Торвальдс читает Таненбаум и разочаровывается в его оси и в 1991 выкладывает в открытый доступ ось, которая содержит ядро, которое монолитно
    * Таненбаум критикует linux, говоря, что архитектура х86 скоро умрет, а linux написана только под нее.
    * Linux интегрирует Linux с GNU. Так и появилась GNU Linux.
---

## 4.	Задачи и механизмы, реализуемые в рамках функции операционной системы по обеспечению интерфейса между пользовательскими приложениями и аппаратным обеспечением вычислительного узла.

### Основные функции ОС:
* Управление разработкой и исполнением пользовательского программного обеспечения
  * ПО должно быть независимо от аппаратного обеспечения
  * Нужно разработчику дать инструменты, которые абстрагируют его от аппаратного слоя, что реализуется через __API__
  * Реализация API
    * > Мы пишем на java под windows, но мы не задумываемся о том, как устроен интерфейс взаимодействия java с windows. 
    * > Чтение файла: мы не задумываемся о том, как файл читается
* Реализация управления и исполнения программ
    * > Щелкнули по браузеру и он запустился. Произошло множество действий от OS до того, как мы увидели окно браузера.
* Приложение нужно поддерживать ресурсами
* Обнаружение и обработка ошибок
    * Ловим какую-то ошибку и случается сбой
    * Таким образом нам нужно правильно обрабатывать ошибки
* Предоставление высокоуровневого доступа к устройствам ввода/вывода
    * > Мы не задумываемся о том, как устроен ввод/вывод на аппаратном уровне, мы абстрагированы от этого
 * Управление хранением данных - **Store**
    * Обеспечить проверку прав доступа
    * Обеспечить отложенную запись в **Store**
  * Мониторинг ресурсов
    * Приложение должно быть производительным на всех устройствах 
---

## 5.	Принципы организации эффективного использования ресурсов компьютера. Критерии эффективности. Подходы к решению многокритериальной задачи.

* Оптимизация использования ресурсов
    * Хотим, чтобы вложенные средства в аппаратное обеспечение продукта работали по максимуму за счет программного обеспечения.
    * Нужен механизм, который обеспечит многокритериальную оптимизацию
    * Одно из таких решений:
      * ![pdca-img](https://cdn8.bigcommerce.com/s-10c6f/product_images/uploaded_images/pdca-circle-image.png)
      * [PDCA](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB_%D0%94%D0%B5%D0%BC%D0%B8%D0%BD%D0%B3%D0%B0) (__Plan-Do-Check-Act__ - __цикл Деминга__) решение - выполняем управление ресурсами и процессами в цикле
        * P - Планирование того, что мы хотим сделать
        * D - Выполнение плана
        * C - Проверка того, что мы хотели выполнить 
        * A - Вносим изменения, если мы не достигли соответствующих показателей
* Поддержка эксплуатации вычислительного узла
  * О Чем речь? Когда используются программы, могут происходить нештатные ситуации с оборудованием, в ос может проникнуть вирус. Для борьбы с такими ситуациями есть ряд механизмов:
    * Системы диагностик - помогают отследить состояние вычислительного узла, например __TOP__ в LInux
    * Средства для восстановления конфигурации ОСи
    * Средства для восстановления данных
      * Создание backup'ов
* Поддержка развития самой операционной системы - появляется новое ПО, новые технологии, мы можем что-то недотестировать и это выяснится в процессе эксплуатации.
  * Механизмы автоматического обновления
  * Механизмы, связанные с изменениями ошибок
---

## 6.	Виды архитектур ядер операционных систем. Общая характеристика каждого вида, достоинства и недостатки.

#### 1 - Монолитная архитектура

  * Все модули находятся в рамках одного адресного пространства, компилируются как совокупность процедур, линкуясь в большой последовательно исполняемый код

  * Монолитная архитектура соответствует принципу модульной организации
  ##### Преимущества:
    1) Быстродействие, все всех видят, каждый может каждого вызвать
    2) Все безопасно - все решения принимаются в ядре
  ##### Недостатки:
    1) Проблемы с надежность, потому что ядро должно быть резидентным, а компонентов очень много
    2) Проблемы с памятью опять же из-за того, что нужно обеспечивать резидентность ядру
    3) Проблема возникает, когда появляется много __services__, появляется необходимость разделить их

#### 2 - Многослойная архитектура (это не новая архитектура, это концепция)
  ##### Преимущества:
    1) Универсальность
    2) Масштабируемость
    3) При сегментировании уровней можно изменять большую часть всего (линукс)
  ##### Недостатки:
    1) Если не линукс, то перезагрузка после изменения чего-либо всё ещё требуется
    2) Ядро всё ещё резидентно
    3) Плохая Производительность
    4) Упирается в производительность памяти и процессора

#### 3 - Микроядерная архитектура
  ##### Преимущества:
    1) В ядре только необходимый код (экономия памяти)
    2) Можно строить распределённые системы (подключать различные сервера, в зависимости от текущих нужд)
  ##### Недостатки:
    1) Низкая производительность (переключение между режимами (kernel и user) серверов и приложений занимает время)
    2) Проблемы с безопасностью (в режим ядра могут попасть опасные приложения и это нужно отдельно контролировать)


#### 4 - Наноядро
Еще меньше функционала оставим в ядре

#### 5 - Экзоядро
Операционные системы, которые были бы разработаны под определенное оборудование. Там с оборудованием разрешают взаимодействовать напрямую. 

---

## 7.	Монолитная архитектура операционной системы. Подробное описание компонентов (слоев), их назначение и взаимодействие между собой. Достоинства и недостатки монолитной архитектуры ядра.

//Добавить картинку этого говна

> Все модули находятся в рамках одного адресного пространства, компилируются как совокупность процедур, линкуясь в большой последовательно исполняемый код
__Монолитная архитектура соответствует принципу модульной организации__
### Выделили несколько слоев монолитной архитектуры
* __Main program__ - один модуль, взаимодействует с сервисами, может и с утилитами
* __Services__ - совокупность модулей, взаимодействует с утилитами
* __utilities__ - совокупность модулей, взаимодействует с аппаратным обеспечением

### Зачем нужно такое разделение ?
* Есть пользовательское по
* Есть аппаратное обеспечение
* Утилиты - это драйвера, они обеспечивают взаимодействие с реальным оборудованием, каждая утилита реализует протокол взаимодействия с контроллером
* Main program - это интерфейс, который обеспечивает системный вызов
  * > Какое-то пользовательское программное обеспечение делает __SYSTEM CALL__ и __Main program__ понимает, какие ресурсы нужно выделить и что сделать, чтобы обработать этот системный вызов
  * Как это происходит ?
    * Пользовательское __по__ вмещает в свое адресное пространство в качестве параметров некий идентификатор системного вызова (например получение файла) и инициирует программное прерывание. В этот момент управление переходит к ядру, ядро смотрит на системный вызов и понимает, что с ним нужно сделать. Теперь нужно его выполнить:
      * __Utilities__ могут работать только с железом, поэтому выделяется средний слой __services__
      * __Main program__ дергает один или совокупность __services__
      * __Services__ дергают __utilities__ и обеспечивает выполнение задачи или выкидывает ошибку, докладывает главной программе, сообщив об успешном выполнении или выдавая ошибку
#### Преимущества монолитной архитектуры
* Быстродействие, все всех видят, каждый может каждого вызвать
* Все безопасно - все решения принимаются в ядре
#### Недостатки монолитной архитектуры
* Проблемы с надежность, потому что ядро должно быть резидентным, а компонентов очень много
* Проблемы с памятью опять же из-за того, что нужно обеспечивать резидентность ядру
* Проблема возникает, когда появляется много __services__, появляется необходимость разделить их

---

## 8.	Концепция многослойного ядра операционной системы. Подробное описание слоев, их назначение. 

 Многослойная архитектура (это не новая архитектура, это концепция)

 // Картинку хуйни добавить 
 
__Наша операционная система это набор концентрических слоев:__
* __Hard ware__
* __Средство аппаратной поддержки ядра__
  * Система прерываний
  * Средство связанной с поддержкой привилегированного режима
  * Средство поддержки виртуальной памяти
  * Смена регистровых контекстов (сохранение состояний регистров)
  * Системный таймер 
  * Защита памяти
* __Машинно зависимые модули (HAL)__
  * Это та часть кода ядра, которая зависит от конкретной платформы. Независимость от программного обеспечения, система должна иметь возможность работать с разным железом.
* __Базовые механизмы ядра__ - модули которые могут работать с нужными структурами данных, они обеспечивают выполнение плана, сгенерированного менеджером ресурсов
* __Менеджеры ресурсов__ - составляет план выполнения команд
* __Слой интерфейса - API - слой системных вызовов__
* __Снаружи находится наше программное обеспечение__

__Если архитектура монолитная, то все эти слои организованны в ядре__
 ##### Преимущества:
    1) Универсальность
    2) Масштабируемость
    3) При сегментировании уровней можно изменять большую часть всего (линукс)
  ##### Недостатки:
    1) Если не линукс, то перезагрузка после изменения чего-либо всё ещё требуется
    2) Ядро всё ещё резидентно
    3) Плохая Производительность
    4) Упирается в производительность памяти и процессора


---

## 9.	Микроядерная архитектура операционной системы. Подробное описание компонентов, их назначение и взаимодействие между собой. Достоинства и недостатки микроядерной архитектуры ядра.

![img](сюда вставить)
### Описание компонентов
* __Микроядро__ - Микроядро защищено от остальных частей ОС и приложений. В состав микроядра обычно входят машинно-зависимые модули, а также модули, выполняющие базовые (но не все!) функции ядра по управлению процессами, обработке прерываний, управлению виртуальной памятью, пересылке сообщений и управлению устройствами ввода-вывода, связанные с загрузкой или чтением регистров устройств.
* __Сервера ОС__ - компоненты ОС, обслуживающие запросы приложений пользователей, утилит и системных обрабатывающих программ, менеджеры ресурсов, здесь они вынесены в пользовательский режим. 
* __Средства аппаратной поддержки ОС__ - различные утилиты.


#### Как именно эта архитектура работает ?
* Предположи(нить)м, что приложение решило, что ему нужно сделать какую-то операцию, оно делает вызов в ядро, ядро допустим приняло решение, что нужно выделить память, сервер памяти выделит память и вернет результат в ядро, ядро вернет результат в приложение.


![img](сюда вставить)

### В чем плюс этой архитектуры ?
* __Простота реализации__ (ядро и компоненты реализуют чётко определённую функциональность, поэтому размер их кода невелик);
* __Простота отладки__ (компоненты — обычные процессы, поэтому могут отлаживаться с помощью инструментов, созданных для отладки процессов);
* __Надёжность__ (в ОС с микроядерной архитектурой ошибка в одном из компонентов приведёт к завершению процесса компонента; в ОС с монолитным ядром отказ компонента приведёт к отказу ОС);
* __Модульность__ (в микроядерной ОС большее число компонентов может быть запущено и остановлено по необходимости; например, для исправления ошибки можно внести изменения в код компонента, скомпилировать новый компонент, остановить старый и запустить новый)

### В чем минусы?
* __Производительность__ - нужно производить много переключений, на что будет тратиться время.

---

## 10.	Понятия процесса, потока, нити, задания. Их определения, назначение и различия между собой.

#### Процесс - совокупность набора исполняемых команд, ассоциированных с ними ресурсов и статуса исполнения, находящаяся под управлением ОС.
* Процесс существует до тех пор, пока система может им управлять.
* Каждый процесс уникален для ОС.
* Существует возможность запустить один и тот же процесс несколько раз, но у каждого из запущенных процессов будет свой (различный) статус.
* Процессу выделяется адресное пространство, при этом ОС следит за тем,чтобы процессы не трогали чужие адресные пространства (идея изоляции процессов)

#### Поток - подчасть процесса, оперирующая с одним определённым адресным пространством и выполняющая часть набора команд.
* Разделение процесса на потоки происходит на уровне ОС.
* Несколько потоков одного процесса имеют доступ к одним и тем же ресурсам.
* Потоки не защищены друг от друга.
* Потоки имеют разное время исполнения, т.е. происходит изолирование потоков.

#### Волокно - это составляющая потока, которым управляет сама программа, а не ОС.
* Помогает избежать проблем с планировщиком (например, если один поток еще не закончит работать, а результаты его работы нужны другому потоку), которые были до этого.
* Идея примерно в том, что один поток может содержать несколько волокон, при этом для них существует общая память и прочие ресурсы.
* Волокна выполняются ТОЛЬКО в пользовательском режиме (не привилегированный доступ и не режим ядра).
* Волокна работают в промежутки времени, выделенные системой для потока, и внутри этого времени они выполняются последовательно, а кому сколько работать - определяется в программе.

#### Задание 
Несколько процессов объединяются в задания для ограничения общих ресурсов. 
* Задание имеет лимиты для количества ресурсов, которое может для себя просить и квоты на максимальное количество процессов.


### Еще раз подытожим хуй залупа пизда манда бля иди в очко
* __Задание__ - совокупность процессов, квоты на их количество и лимитов на ресурсы. 
* __Процесс__ - некоторая заявка для ОС, содержащая в себе инструкции, которые необходимо выполнить. ОС распределяет между ними все ресурсы КРОМЕ процессорного времени.
* __Поток__ - то, из чего состоит процесс, как раз между потоками распределяется процессорное время. Это могут быть как части программы, выполняющие один и тот же код на разных адресных пространствах, чтобы “распараллеливать”, так и разные инструкции, выполняемые параллельно.
* __Волокно__ - составляющее потока. Волокна внутри потока имеют общие ресурсы, в том числе и общее процессорное время. Но при этом, выполняются параллельно, а безопасность их работы - забота программиста.

---
## 11.  Функции подсистемы управления процессами.


---
## 12.  Методы создания процессов в различных операционных системах. Структуры данных о процессах.


---
## 13.  Модель жизненного цикла процесса: состояния процесса, правила переходов между состояниями.


---
## 14.  Виды планирования и их место в жизненном цикле процесса.
#### Двухуровневая модель
* Любому процессу при его рождении присваивается статус «не исполняется». 
* Как только планировщик выбирает этот процесс для исполнения, процесс получает статус «исполняется». 
* Поле исполнения он может завершиться, либо снова получить статус «не исполняется» и ожидать время на исполнение. 
![img](сюда вставить)

Процесс, находящийся в состоянии процесс исполняется, может быть завершен ОС или приостановлен и снова переведен в состояние процесс не исполняется. Приостановка процесса происходит по двум причинам: для его дальнейшей работы потребовалось какое-либо событие (например, завершение операции ввода-вывода) или истек временной интервал, отведенный операционной системой для работы данного процесса. 

После этого ОС по определенному алгоритму выбирает для исполнения один из процессов, находящихся в состоянии не исполняется, и переводит его в состояние исполняется. Новый процесс первоначально помещается в состояние не исполняется. 

Это очень грубая модель, она не учитывает, в частности, то, что процесс, выбранный для исполнения, может все еще ждать события, из-за которого он был приостановлен, и реально к выполнению не готов.

#### Трехуровневая модель
__Шаги: исполнение, готовность, ожидание.__ 
* Процесс при порождении может выполняться. 
* Из готовности планировщик переводит процесс в статус «исполняется». 
* После исполнения процесс либо завершается, либо отправляется в ожидание/готовность. За состоянием ожидания следит определенный процесс ядра ОС. 
* После прерывания ожидания процесс переходит в статус готовности. И снова к исполнению. 

![img](сюда вставить)


Новый процесс попадает в состояние готовность. ОС, пользуясь каким-либо алгоритмом планирования, выбирает один из готовых процессов и переводит его в состояние исполнение. В состоянии исполнение происходит непосредственное выполнение программного кода процесса. 

Выйти из этого состояния процесс может по трем причинам:
* ОС прекращает его деятельность;
* Он не может продолжать свою работу, пока не произойдет некоторое событие, и ОС переводит его в состояние ожидание;
* В результате возникновения прерывания в вычислительной системе (например, прерывания от таймера по истечении предусмотренного времени выполнения) его возвращают в состояние готовность.

Из состояния ожидание процесс попадает в состояние готовность после того, как ожидаемое событие произошло, и он снова может быть выбран для исполнения. 

Наша новая модель хорошо описывает поведение процессов во время их существования, но она не акцентирует внимания на появлении процесса в системе и его исчезновении.

#### Пятиуровневая модель
Рождение – растянутый этап, на котором ОС решает, стоит ли рождать этот процесс. На этом этапе у процесса нет PCB. 
* После рождения процесс переходит в статус «готовность». 
* Из готовности планировщик переводит процесс в статус «исполняется». 
* После исполнения процесс либо завершается, либо отправляется в ожидание.
* За состоянием ожидания следит определенный процесс ядра ОС. 
* После прерывания ожидания процесс переходит в статус готовности. И снова к исполнению. 
* Завершение – растянутый этап завершения процесса: освобождения памяти, нахождение родителя. процесс находится в завершении значительное время пока ОС в поисках. 

---
## 15.  Критерии эффективности и свойства методов планирования процессов, параметры планирования процессов.

---
## 16.  Методы планирования без внешнего управления приоритетами (FCFS, RR, SJF), гарантированное планирование. Описание каждого метода, их достоинства и недостатки.

---
## 17.  Приоритетное планирование с внешним управлением приоритетами, многоуровневые очереди. Описание методов, их достоинства и недостатки.
---
## 18.  Организация планирования процессов в ОС семейств Microsoft Windows
---
## 19.  Принципы работы планировщиков O(1) и CFS в операционных системах GNU/Linux.
---
## 20.  Взаимодействие процессов. Условия взаимоисключения и прогресса. Понятие критической секции. Голодание процессов.
---
## 21.  Алгоритмы реализации взаимоисключений. Формальное описание алгоритмов, их недостатки.
---
## 22.  Семафоры Дейкстра. Решение проблемы «производитель-потребитель» с помощью семафоров.
---
## 23.  Проблемы взаимодействующих процессов. Проблема обедающих философов, проблема писателей и читателей.
---
## 24.  Тупики. Условия возникновения и методы борьбы с тупиками.
---
## 25.  Принципы управления памятью вычислительной системы. Виртуальная память и преобразование адресов.
---
## 26.  Методы распределения оперативной памяти без использования внешней памяти.
---
## 27.  Страничная организация виртуальной памяти. Вычисление физических адресов при страничной организации виртуальной памяти.
---
## 28.  Методы оптимизации потребления ресурсов при страничной организации виртуальной памяти. Сегментно-страничная организация виртуальной памяти.
---
## 29.  Методы организации хранения данных в файловых системах: непрерывная последовательность блоков, связный список, таблица размещения файлов.
---
## 30.  Методы организации хранения данных в файловых системах: индексные дескрипторы.
---
## 31.  Журналируемые файловые системы. Назначение и виды журналов.
---
## 32.  Обоснование необходимости и принципы построения распределенных ОС.
---
## 33.  Алгоритмы управления памятью в распределенных ОС. Их преимущества и недостатки.
---
## 34.  Методы управление файлами и каталогами в распределенных ОС. Их преимущества и недостатки.
---
## 35.  Синхронизация времени в распределенных системах. Метод Лампорта для синхронизации времени.
---
## 36.  Технологии виртуализации. Виды виртуализации: эмуляция аппаратуры, полная виртуализация, паравиртуализация, виртуализация уровня ядра операционной системы. Их достоинства и недостатки.
---
## 37.  Архитектура облачных систем. Основные компоненты, их назначение и способы взаимодействия. Принципы мониторинга и управления производительностью в облачных системах.












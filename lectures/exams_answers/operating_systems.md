## 1. Функции и механизмы ОС, появившиеся на этапе программ-диспетчеров, предшественников операционных систем.

* Сначала компьютеры работали на **архитектуре Фон Неймана**
![img](https://sun9-14.userapi.com/impg/IR2frlkgJ5lfBghMtuPjLp01tvIM7NC3LH1NzQ/7q7oM_iRaAI.jpg?size=1426x610&quality=96&proxy=1&sign=f68e6223db7a14e7240304535814190a&type=album)
  * Суть данной архитектуры заключалась в том, что **cpu** был связан с **ram**, **input**, **output** и **storage**.
  * Проблема **архитектуры Фон Неймана** заключалась в сложности параллельного выполнения программ, так как было сложно достичь синхронизации данных на входе и выходе

#### Задача - распараллеливать процессы, которые проходят через cpu
#### Решение - программа диспетчер
**Программы-диспетчеры** появились для автоматизации загрузки и линковки данных, которые писались под конкретную машину. Когда осознали, что многие части кода повторяются, решили отвести специально место в оперативной памяти для пакетов(библиотек), отсюда возникли задачи:

* автоматизировать линковку (связь приложений с ячейками памяти),

* оптимизировать взаимодействия с устройствами ввода/вывода.


### Задача - оптимизация взаимодействия с устройствами ввода вывода и хранения

* Все пути идут через процессор -> (**при архитектуре Фон Неймана**)
* Проблема - мало **ram** для хранения огромного количества данных, если временные данные хранить в **ram**
* Проблема - процессор при такой работе работает не рационально, потому что выполняет простые операции, которые не используют всю его мощь

##### Таким образом был придуман принципы распараллеливания процессов

При параллельном выполнении процессов возникают сложности:
* Хранилище не гарантирует нам быстрый доступ к данным, из-за этого мы не знаем, когда кончится операция ввода-вывода
* Основная проблема в том, что таким образом нам сложно синхронизировать параллельность разгрузки погрузки памяти
### Функции программ-диспетчеров
##### Спулинг
  * Взаимодействие с input/output/storage занимало очень много времени из-за однозадачности CPU. Распараллеливание будем совершать через простейший процессор - контроллер.
**Спулинг** (SPOOL, Simultaneous Peripheral Output On-Line) - процесс взаимодействия ram/storage через контроллер
  * POOL (спулинг) — спулинг это буферизация данных перед их обработкой
Контроллер сохранял в своих регистрах не только те данные, которые запрашивались, но и те, которые могут потребоваться в ближайшее время.
#### Прерывания
  * **Прерывание** (Interrupt) - специальный сигнал от контроллера к CPU сообщающий о некотором событии (наступлении события), прерывающий ход выполнения текущей программы и передающий управление обработчику прерываний.
  
#### Однопрограммная пакетная обработка
* __Пакет__ – совокупность программных модулей, обрабатываемых данных и конфигураций. 

---

## 2. Функции и механизмы ОС, появившиеся на этапе мультипрограммных операционных систем.

#### Задача: выполнять одновременно несколько задач

##### В чем необходимость ?

* Наши приложения обладают различным поведением, соответственно, они с разной нагрузкой воздействуют на CPU
* Появление псеводопараллельности:
  * Несмотря на то, что процессор "не простаивает", переключение между процессами будет занимать время.
![img](https://sun9-4.userapi.com/impg/fwwgGnoBHluGlrUrFiLw-IcEQYGM4DLb_Gox2Q/ZyDx1drTMmw.jpg?size=712x248&quality=96&proxy=1&sign=519c0d4d4b1a5a4f124ef5f8530f9a68&type=album)

### Функции
 * ##### 1 Задача - обеспечение времени разделения процессора
   * __Что нужно для разделения времени процессора?__
      * Есть 2 процесса. Будем чередовать их выполнение.
      * Как сделать переход ?
      * Нужно запомнить место, где процесс остановился (сохранить контекст процесса).
        * Сохранить значения регистров.
        * Загрузить данные в регистры для нового процесса **(это требует времени)**
    * __Как процессу остановить другой процесс?__
      * __Решение на аппаратном уровне (как контроллер для spooling'a)__
        * Добавили таймер, который через равные промежутки прерывает выполнение процессов.
        * Прерывание - это передача управления процессами диспетчеру прерывания
 * ##### 2 Задача - необходимо разделять память
      * __Virtual Memory__ - способ адресации, при котором каждой программе выделяется виртуальное пространство, адресуемое с нуля. ОС подменяет виртуальный адрес на реальный. Появляется задача защиты областей памяти.
 * ##### 3 Задача - обеспечение защиты программы от действия других программ (задача защиты областей памяти)
    * Надо защищать адресное пространство, т.к. в результате ошибки программиста, мы можем выйти за пределы адресного пространства, при записи туда, возникнет сбой.
    
    * __Механизм защиты памяти - аппаратное решение__

      * Он будет проверять права доступа для записи или чтения
      * Прерывание по защите памяти:
        * Простое решение - уничтожить процесс, которые пытается сделать что-то противозаконное
 
 * ##### 4 Задача - планирование выполнения программы
      * Каждый процесс считает, что он имеет полное адресное пространство, но физическая память ограничена, поэтому нужно планировать использование памяти процессами. ОС также должна решать когда и какой процесс будет выполняться, при каких условиях переключаться.     

 * ##### 5 Задача - задача по синхронизации
    * Нужны механизмы, которые обеспечат межпроцессорную синхронизацию
 * ##### 6 Задача - задача доступа к информации на внешнем хранилище
    * При мультипрограммности появляется проблема контролируемого доступа к данным в хранилище
    * нужно обеспечить очередь
    * Нужно правильно выбрать адреса в хранилище (__для ускорения линковки например__)
      * Можно хранить программы в библиотеке на хранилище и подгружать их (__нужна особая адресация__)
    * __Появляется механизм файлово - каталоговой системы__
      * Даем уникальные имена
      * Группируем их в директории
      * Выстраиваем иерархию между ними
      * Получаем контролируемый доступ к данным в хранилище

--- 
## 3. Функции и механизмы, появившиеся на этапах сетевых и мобильных (универсальных) операционных систем.

### сетевые операционные системы
* Проблемы
  * Много данных
  * Машины очень дорогие
  * Количество потребителей растет => возникает разделение машинного времени среди пользователей
  * Накладные расходы
  * Ввод и вывод - узкое место. Много программ, один оператор, который вводит программ в компьютер -> снижение эффективности использования компьютера
#### Решение - Удаленные терминалы
* Объединим входные и выходные устройства
* Звоним в вычислительный узел и просим что-то вычислить
* Появляется многотерминальная проблема
  * Безопасность - нет оператора, который контролирует ввод и вывод, можно внести вирус
    * Появляется механизм аутентификации и авторизации
    * Вводится понятие пользователя и пользовательский режим
* Появляется удаленное взаимодействие между различными вычислительными узлами
  * есть 2 города с машинами, появляется механизм по обмену данными между машинами
  * __Появляются распределенные операционные системы__

### открытые операционные системы
* Предпосылка
  * Проблема переносимости кода
  * Нужна ось, которая может запускаться на различных компьютерах
* Проблемы:
  * Нужна ось, которая сама по себе будет работать на языке высокого уровня
* Bella boretlis - великая компания
  * Они создают __Unix__ и __C__
  * В 1969 году выходит операционная система unix (__UNICS__), написанная на ассемблере
  * На следующем этапе эта команда разрабатывает язык би и unix переписывается под нее уже существующую версию
  * Выходит 3 редакция с компилятором си 
  * Выходит 4 редакция с ядром, написанным на си
  * Выходит 5 редакция, которая полностью написана на си
  * Таким образом появилась универсальная операционная система **Unix**

## Как появился Linux
* Появился проект GNU (__GNU NOT UNIX__)
  * Разрабатывают компилятор GCC
  * Разрабатываются утилиты и модули на Си
  * Нужно написать ядро
    * Студент Линукс Торвальдс читает Таненбаум и разочаровывается в его оси и в 1991 выкладывает в открытый доступ ось, которая содержит ядро, которое монолитно
    * Таненбаум критикует linux, говоря, что архитектура х86 скоро умрет, а linux написана только под нее.
    * Linux интегрирует Linux с GNU. Так и появилась GNU Linux.
---

## 4.	Задачи и механизмы, реализуемые в рамках функции операционной системы по обеспечению интерфейса между пользовательскими приложениями и аппаратным обеспечением вычислительного узла.

### Основные функции ОС:
* Управление разработкой и исполнением пользовательского программного обеспечения
  * ПО должно быть независимо от аппаратного обеспечения
  * Нужно разработчику дать инструменты, которые абстрагируют его от аппаратного слоя, что реализуется через __API__
  * Реализация API
    * > Мы пишем на java под windows, но мы не задумываемся о том, как устроен интерфейс взаимодействия java с windows. 
    * > Чтение файла: мы не задумываемся о том, как файл читается
* Реализация управления и исполнения программ
    * > Щелкнули по браузеру и он запустился. Произошло множество действий от OS до того, как мы увидели окно браузера.
* Приложение нужно поддерживать ресурсами
* Обнаружение и обработка ошибок
    * Ловим какую-то ошибку и случается сбой
    * Таким образом нам нужно правильно обрабатывать ошибки
* Предоставление высокоуровневого доступа к устройствам ввода/вывода
    * > Мы не задумываемся о том, как устроен ввод/вывод на аппаратном уровне, мы абстрагированы от этого
 * Управление хранением данных - **Store**
    * Обеспечить проверку прав доступа
    * Обеспечить отложенную запись в **Store**
  * Мониторинг ресурсов
    * Приложение должно быть производительным на всех устройствах 
  * Оптимизация использования ресурсов
    * Хотим, чтобы вложенные средства в аппаратное обеспечение продукта работали по максимуму за счет программного обеспечения.
    * Нужен механизм, который обеспечит многокритериальную оптимизацию
    * Одно из таких решений:
      * ![pdca-img](https://cdn8.bigcommerce.com/s-10c6f/product_images/uploaded_images/pdca-circle-image.png)
      * [PDCA](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB_%D0%94%D0%B5%D0%BC%D0%B8%D0%BD%D0%B3%D0%B0) (__Plan-Do-Check-Act__ - __цикл Деминга__) решение - выполняем управление ресурсами и процессами в цикле
        * P - Планирование того, что мы хотим сделать
        * D - Выполнение плана
        * C - Проверка того, что мы хотели выполнить 
        * A - Вносим изменения, если мы не достигли соответствующих показателей
* Поддержка эксплуатации вычислительного узла
  * О Чем речь? Когда используются программы, могут происходить нештатные ситуации с оборудованием, в ос может проникнуть вирус. Для борьбы с такими ситуациями есть ряд механизмов:
    * Системы диагностик - помогают отследить состояние вычислительного узла, например __TOP__ в Linux
    * Средства для восстановления конфигурации ОСи
    * Средства для восстановления данных
      * Создание backup'ов
* Поддержка развития самой операционной системы - появляется новое ПО, новые технологии, мы можем что-то недотестировать и это выяснится в процессе эксплуатации.
  * Механизмы автоматического обновления
  * Механизмы, связанные с изменениями ошибок
---

## 5.	Принципы организации эффективного использования ресурсов компьютера. Критерии эффективности. Подходы к решению многокритериальной задачи.

----------------------------------------------
----------------------------------------------
----------------------------------------------
----------------------------------------------
----------------------------------------------
----------------------------------------------
----------------------------------------------
----------------------------------------------
Тут надо искать инфу
---

## 6.	Виды архитектур ядер операционных систем. Общая характеристика каждого вида, достоинства и недостатки.

#### 1 - Монолитная архитектура

  * Все модули находятся в рамках одного адресного пространства, компилируются как совокупность процедур, линкуясь в большой последовательно исполняемый код

  * Монолитная архитектура соответствует принципу модульной организации
  ##### Преимущества:
    1) Быстродействие, все всех видят, каждый может каждого вызвать
    2) Все безопасно - все решения принимаются в ядре
  ##### Недостатки:
    1) Проблемы с надежность, потому что ядро должно быть резидентным, а компонентов очень много
    2) Проблемы с памятью опять же из-за того, что нужно обеспечивать резидентность ядру
    3) Проблема возникает, когда появляется много __services__, появляется необходимость разделить их

#### 2 - Многослойная архитектура (это не новая архитектура, это концепция)
  ##### Преимущества:
    1) Универсальность
    2) Масштабируемость
    3) При сегментировании уровней можно изменять большую часть всего (линукс)
  ##### Недостатки:
    1) Если не линукс, то перезагрузка после изменения чего-либо всё ещё требуется
    2) Ядро всё ещё резидентно
    3) Плохая Производительность
    4) Упирается в производительность памяти и процессора

#### 3 - Микроядерная архитектура
  ##### Преимущества:
    1) В ядре только необходимый код (экономия памяти)
    2) Можно строить распределённые системы (подключать различные сервера, в зависимости от текущих нужд)
  ##### Недостатки:
    1) Низкая производительность (переключение между режимами (kernel и user) серверов и приложений занимает время)
    2) Проблемы с безопасностью (в режим ядра могут попасть опасные приложения и это нужно отдельно контролировать)


#### 4 - Наноядро
Еще меньше функционала оставим в ядре

#### 5 - Экзоядро
Операционные системы, которые были бы разработаны под определенное оборудование. Там с оборудованием разрешают взаимодействовать напрямую. 

---

## 7.	Монолитная архитектура операционной системы. Подробное описание компонентов (слоев), их назначение и взаимодействие между собой. Достоинства и недостатки монолитной архитектуры ядра.

//Добавить картинку этого говна

> Все модули находятся в рамках одного адресного пространства, компилируются как совокупность процедур, линкуясь в большой последовательно исполняемый код
__Монолитная архитектура соответствует принципу модульной организации__
### Выделили несколько слоев монолитной архитектуры
* __Main program__ - один модуль, взаимодействует с сервисами, может и с утилитами
* __Services__ - совокупность модулей, взаимодействует с утилитами
* __utilities__ - совокупность модулей, взаимодействует с аппаратным обеспечением

### Зачем нужно такое разделение ?
* Есть пользовательское по
* Есть аппаратное обеспечение
* Утилиты - это драйвера, они обеспечивают взаимодействие с реальным оборудованием, каждая утилита реализует протокол взаимодействия с контроллером
* Main program - это интерфейс, который обеспечивает системный вызов
  * > Какое-то пользовательское программное обеспечение делает __SYSTEM CALL__ и __Main program__ понимает, какие ресурсы нужно выделить и что сделать, чтобы обработать этот системный вызов
  * Как это происходит ?
    * Пользовательское __по__ вмещает в свое адресное пространство в качестве параметров некий идентификатор системного вызова (например получение файла) и инициирует программное прерывание. В этот момент управление переходит к ядру, ядро смотрит на системный вызов и понимает, что с ним нужно сделать. Теперь нужно его выполнить:
      * __Utilities__ могут работать только с железом, поэтому выделяется средний слой __services__
      * __Main program__ дергает один или совокупность __services__
      * __Services__ дергают __utilities__ и обеспечивает выполнение задачи или выкидывает ошибку, докладывает главной программе, сообщив об успешном выполнении или выдавая ошибку
#### Преимущества монолитной архитектуры
* Быстродействие, все всех видят, каждый может каждого вызвать
* Все безопасно - все решения принимаются в ядре
#### Недостатки монолитной архитектуры
* Проблемы с надежность, потому что ядро должно быть резидентным, а компонентов очень много
* Проблемы с памятью опять же из-за того, что нужно обеспечивать резидентность ядру
* Проблема возникает, когда появляется много __services__, появляется необходимость разделить их

---

## 8.	Концепция многослойного ядра операционной системы. Подробное описание слоев, их назначение. 

 Многослойная архитектура (это не новая архитектура, это концепция)

 // Картинку хуйни добавить 
 
__Наша операционная система это набор концентрических слоев:__
* __Hard ware__
* __Средство аппаратной поддержки ядра__
  * Система прерываний
  * Средство связанной с поддержкой привилегированного режима
  * Средство поддержки виртуальной памяти
  * Смена регистровых контекстов (сохранение состояний регистров)
  * Системный таймер 
  * Защита памяти
* __Машинно зависимые модули (HAL)__
  * Это та часть кода ядра, которая зависит от конкретной платформы. Независимость от программного обеспечения, система должна иметь возможность работать с разным железом.
* __Базовые механизмы ядра__ - модули которые могут работать с нужными структурами данных, они обеспечивают выполнение плана, сгенерированного менеджером ресурсов
* __Менеджеры ресурсов__ - составляет план выполнения команд
* __Слой интерфейса - API - слой системных вызовов__
* __Снаружи находится наше программное обеспечение__

__Если архитектура монолитная, то все эти слои организованны в ядре__
 ##### Преимущества:
    1) Универсальность
    2) Масштабируемость
    3) При сегментировании уровней можно изменять большую часть всего (линукс)
  ##### Недостатки:
    1) Если не линукс, то перезагрузка после изменения чего-либо всё ещё требуется
    2) Ядро всё ещё резидентно
    3) Плохая Производительность
    4) Упирается в производительность памяти и процессора


---

## 9.	Микроядерная архитектура операционной системы. Подробное описание компонентов, их назначение и взаимодействие между собой. Достоинства и недостатки микроядерной архитектуры ядра.

![img](сюда вставить)
### Описание компонентов
* __Микроядро__ - Микроядро защищено от остальных частей ОС и приложений. В состав микроядра обычно входят машинно-зависимые модули, а также модули, выполняющие базовые (но не все!) функции ядра по управлению процессами, обработке прерываний, управлению виртуальной памятью, пересылке сообщений и управлению устройствами ввода-вывода, связанные с загрузкой или чтением регистров устройств.
* __Сервера ОС__ - компоненты ОС, обслуживающие запросы приложений пользователей, утилит и системных обрабатывающих программ, менеджеры ресурсов, здесь они вынесены в пользовательский режим. 
* __Средства аппаратной поддержки ОС__ - различные утилиты.


#### Как именно эта архитектура работает ?
* Предположи(нить)м, что приложение решило, что ему нужно сделать какую-то операцию, оно делает вызов в ядро, ядро допустим приняло решение, что нужно выделить память, сервер памяти выделит память и вернет результат в ядро, ядро вернет результат в приложение.


![img](сюда вставить)

### В чем плюс этой архитектуры ?
* __Простота реализации__ (ядро и компоненты реализуют чётко определённую функциональность, поэтому размер их кода невелик);
* __Простота отладки__ (компоненты — обычные процессы, поэтому могут отлаживаться с помощью инструментов, созданных для отладки процессов);
* __Надёжность__ (в ОС с микроядерной архитектурой ошибка в одном из компонентов приведёт к завершению процесса компонента; в ОС с монолитным ядром отказ компонента приведёт к отказу ОС);
* __Модульность__ (в микроядерной ОС большее число компонентов может быть запущено и остановлено по необходимости; например, для исправления ошибки можно внести изменения в код компонента, скомпилировать новый компонент, остановить старый и запустить новый)

### В чем минусы?
* __Производительность__ - нужно производить много переключений, на что будет тратиться время.

---

## 10.	Понятия процесса, потока, нити, задания. Их определения, назначение и различия между собой.

#### Процесс - совокупность набора исполняемых команд, ассоциированных с ними ресурсов и статуса исполнения, находящаяся под управлением ОС.
* Процесс существует до тех пор, пока система может им управлять.
* Каждый процесс уникален для ОС.
* Существует возможность запустить один и тот же процесс несколько раз, но у каждого из запущенных процессов будет свой (различный) статус.
* Процессу выделяется адресное пространство, при этом ОС следит за тем,чтобы процессы не трогали чужие адресные пространства (идея изоляции процессов)

#### Поток - подчасть процесса, оперирующая с одним определённым адресным пространством и выполняющая часть набора команд.
* Разделение процесса на потоки происходит на уровне ОС.
* Несколько потоков одного процесса имеют доступ к одним и тем же ресурсам.
* Потоки не защищены друг от друга.
* Потоки имеют разное время исполнения, т.е. происходит изолирование потоков.

#### Волокно - это составляющая потока, которым управляет сама программа, а не ОС.
* Помогает избежать проблем с планировщиком (например, если один поток еще не закончит работать, а результаты его работы нужны другому потоку), которые были до этого.
* Идея примерно в том, что один поток может содержать несколько волокон, при этом для них существует общая память и прочие ресурсы.
* Волокна выполняются ТОЛЬКО в пользовательском режиме (не привилегированный доступ и не режим ядра).
* Волокна работают в промежутки времени, выделенные системой для потока, и внутри этого времени они выполняются последовательно, а кому сколько работать - определяется в программе.

#### Задание 
Несколько процессов объединяются в задания для ограничения общих ресурсов. 
* Задание имеет лимиты для количества ресурсов, которое может для себя просить и квоты на максимальное количество процессов.


### Еще раз подытожим хуй залупа пизда манда бля иди в очко
* __Задание__ - совокупность процессов, квоты на их количество и лимитов на ресурсы. 
* __Процесс__ - некоторая заявка для ОС, содержащая в себе инструкции, которые необходимо выполнить. ОС распределяет между ними все ресурсы КРОМЕ процессорного времени.
* __Поток__ - то, из чего состоит процесс, как раз между потоками распределяется процессорное время. Это могут быть как части программы, выполняющие один и тот же код на разных адресных пространствах, чтобы “распараллеливать”, так и разные инструкции, выполняемые параллельно.
* __Волокно__ - составляющее потока. Волокна внутри потока имеют общие ресурсы, в том числе и общее процессорное время. Но при этом, выполняются параллельно, а безопасность их работы - забота программиста.

---
## 11.  Функции подсистемы управления процессами.

####Подсистема управления процессами - одна из основных подсистем, влияющих на функционирование компьютера.

##### К основным функциям этой подсистемы относят: 
    1) создание процессов и потоков
    2) обеспечение процессов и потоков необходимыми ресурсами
    3) изоляция процессов
    4) планирование выполнения процессов и потоков
    5) диспетчеризация потоков
    6) организация межпроцессного взаимодействия
    7) синхронизация процессов и потоков
    8) завершение и уничтожение.
##### Создание процессов
При загрузке ОС обычно создаются несколько процессов (высокоприоритетные и фоновые). Новый процесс может быть создан по запросу текущего. 
##### Обеспечение процессов ресурсами
ОС поддерживает в памяти информационные структуры, в которые записывает какие ресурсы выделены каждому процессу. Некоторые ресурсы выделяются при создании, а некоторые по запросу во время выполнения (динамически). Ресурсы могут быть выданы процессу на время его жизни или только на определенный период.
##### Изоляция процессов
Для того, чтобы процессы не могли вмешиваться в распределение ресурсов, а также не могли повредить данные друг друга, задачей ОС является изоляция одного процесса от другого. Для этого ОС обеспечивает каждый процесс отдельным адресным пространством.
##### Планирование и диспетчеризация процессов и потоков
Процесс рассматривается как заявка на потребление всех видов ресурсов, кроме  процессорного времени. Этот ресурс распределяется между потоками. Переход от выполнения одного потока к другому выполняется в результате планирования и диспетчеризации. 

  * Планирование - работа по определению момента, в который необходимо прервать выполнение текущего потока и начать выполнять другой поток.

  * Диспетчеризация заключается в реализации решения, найденного в результате планирования, т.е переключение с одного потока на другой. Проходит в три шага:
    1) Сохранение контекста текущего потока.
    2) Загрузка контекста выбранного потока в результате планирования
    3) Запуск нового потока на выполнение
##### Синхронизация потоков
Синхронизация потоков является важной функцией подсистемы управления процессами и потоками. ОС представляют множество механизмов синхронизации(семафоры,мьютексы и т.д), все эти механизмы работают с потоками, а не процессами. Поэтому когда один поток блокируется на семафоре, другие потоки процесса могут продолжить работу.
##### Завершение процессов
Каждый раз когда процесс завершается, ОС предпринимает шаги, чтобы “зачистить следы” его пребывания в системе. Подсистема управления процессами закрывает все файлы, с которыми работал процесс, и освобождает оперативную память, отведенную под него, завершает его потоки.


---
## 12.  Методы создания процессов в различных операционных системах. Структуры данных о процессах.

Нужно хранить такую информацию о процессе, что в любой момент времени можно его приостановить так, что в любой другой момент времени можно было его запустить с того самого места, где он приостановился. 

#### Структуры данных о процессах:
* Основные структуры данных о процессе хранятся в PCB (Process Control Block), они могут описать процесс
#### Таблица процессов
Здесь хранятся такие данные, как: 
> 1) Информация по идентификации процесса PID– Process IDentificator; 
> 2) PPID – Parent PID – хранится для того, чтобы обрабатывать код возврата от дочернего процесса, и, если этот процесс аварийно завершится, обработать ошибку (если обработчика нет, то процесс просто удаляется). Все, кто потерял родительский процесс усыновляются init`ом;
>3) UID информация о пользователе, который запустил этот процесс;
> 4) Регистровая информация;
> 5) Важная информация по управлению процессом -  все данные, для принятия решения по управлению процессом(например, приоритет или статистика использования процесса).

__Zombie процесс__ – процесс, который завершил работу, освободил ресурсы и отправил код завершения родителю, ожидая освобождения PID’а, который он занял, но родитель по каким-то причинам не отреагировал на этот код и не завершил дочерний процесс. 

Процесс в итоге остаётся занимать место в таблице PID’ов, не занимая при этом ресурсов. Init, в свою очередь, не может удочерить этот процесс, так как по факту у него есть родитель, просто этот родитель не позаботился о своём дочернем процессе и не завершил его как следует.

#### Пространство процесса
Эта дополнительная информация, которая требуется ядру ОС во время исполнения процесса, например: заголовки исполняемых файлов, корневой и текущий каталоги и т.д.

__Важно понимать, что выше написанное относится к Unix подобным системам.__ В Windows мы не храним информацию о родителях, а вся информация хранится в виде набора связанных структур. 		

#####Linux
В Linux иерархическая система – каждый процесс знает кем он порожден и помнит своего родителя. Первоначальный процесс init имеет PID = 1. Породить процесс – породить описание процесса. Ни один процесс не сможет получить доступа и ресурсов больше, чем было дано родителем.

#####Windows
Процессы порождаются менеджером процессов, что помогает избегать zombie процессов, но отсюда проблема с безопасностью. Причем самое интересное: все процессы равноправны и любому процессу можно поставить некий маркер (дескриптор), позволяя управлять дочерними процессами, тем самым нарушая иерархию процессов. В этом и есть проблема с безопасностью: может возникнуть проблема с тем, что один процесс монополизирует все ресурсы. 


---
## 13.  Модель жизненного цикла процесса: состояния процесса, правила переходов между состояниями.
#### Двухуровневая модель
__Шаги: исполняется, не исполняется.__ 
* Любому процессу при его рождении присваивается статус «не исполняется». 
* Как только планировщик выбирает этот процесс для исполнения, процесс получает статус «исполняется». 
* Поле исполнения он может завершиться, либо снова получить статус «не исполняется» и ожидать время на исполнение. 
![img](сюда вставить)

Процесс, находящийся в состоянии процесс исполняется, может быть завершен ОС или приостановлен и снова переведен в состояние процесс не исполняется. Приостановка процесса происходит по двум причинам: для его дальнейшей работы потребовалось какое-либо событие (например, завершение операции ввода-вывода) или истек временной интервал, отведенный операционной системой для работы данного процесса. 

После этого ОС по определенному алгоритму выбирает для исполнения один из процессов, находящихся в состоянии не исполняется, и переводит его в состояние исполняется. Новый процесс первоначально помещается в состояние не исполняется. 

Это очень грубая модель, она не учитывает, в частности, то, что процесс, выбранный для исполнения, может все еще ждать события, из-за которого он был приостановлен, и реально к выполнению не готов.

#### Трехуровневая модель
__Шаги: исполнение, готовность, ожидание.__ 
* Процесс при порождении может выполняться. 
* Из готовности планировщик переводит процесс в статус «исполняется». 
* После исполнения процесс либо завершается, либо отправляется в ожидание/готовность. За состоянием ожидания следит определенный процесс ядра ОС. 
* После прерывания ожидания процесс переходит в статус готовности. И снова к исполнению. 

![img](сюда вставить)


Новый процесс попадает в состояние готовность. ОС, пользуясь каким-либо алгоритмом планирования, выбирает один из готовых процессов и переводит его в состояние исполнение. В состоянии исполнение происходит непосредственное выполнение программного кода процесса. 

Выйти из этого состояния процесс может по трем причинам:
* ОС прекращает его деятельность;
* Он не может продолжать свою работу, пока не произойдет некоторое событие, и ОС переводит его в состояние ожидание;
* В результате возникновения прерывания в вычислительной системе (например, прерывания от таймера по истечении предусмотренного времени выполнения) его возвращают в состояние готовность.

Из состояния ожидание процесс попадает в состояние готовность после того, как ожидаемое событие произошло, и он снова может быть выбран для исполнения. 

Наша новая модель хорошо описывает поведение процессов во время их существования, но она не акцентирует внимания на появлении процесса в системе и его исчезновении.

#### Пятиуровневая модель
Рождение – растянутый этап, на котором ОС решает, стоит ли рождать этот процесс. На этом этапе у процесса нет PCB. 
* После рождения процесс переходит в статус «готовность». 
* Из готовности планировщик переводит процесс в статус «исполняется». 
* После исполнения процесс либо завершается, либо отправляется в ожидание.
* За состоянием ожидания следит определенный процесс ядра ОС. 
* После прерывания ожидания процесс переходит в статус готовности. И снова к исполнению. 
* Завершение – растянутый этап завершения процесса: освобождения памяти, нахождение родителя. процесс находится в завершении значительное время пока ОС в поисках. 

![img](сюда вставить)

Теперь для появления в вычислительной системе процесс должен пройти через состояние рождение. При рождении процесс получает в свое распоряжение адресное пространство, в которое загружается программный код процесса; ему выделяются стек и системные ресурсы; устанавливается начальное значение программного счетчика этого процесса и т. д. Родившийся процесс переводится в состояние готовность. При завершении своей деятельности процесс из состояния исполнение попадает в состояние закончил исполнение.

#### Семиуровневая модель
Шаги: пятиуровневая модель + исключительная ситуация + зомби-состояние (только для Linux).
* Если в процессе исполнения возникает ошибка, процесс отправляется в исключительную ситуацию. После решения ошибки из исключительной ситуации процесс получает статус готовности.
* Выход из зомби процесса не всегда возможен.

![img](сюда вставить)


---
## 14.  Виды планирования и их место в жизненном цикле процесса.
Основная цель планирования вычислительного процесса заключается в распределении времени процессора (нескольких процессоров) между выполняющимися заданиями пользователей таким образом, чтобы удовлетворять требованиям, предъявляемым пользователями к вычислительной системе. Такими требованиями могут быть, как это уже отмечалось, пропускная способность, время отклика, загрузка процессора и др.

Все виды планирования, используемые в современных ОС, в зависимости от временного масштаба, делятся на долгосрочное, среднесрочное, краткосрочное и планирование ввода-вывода. Рассматривая частоту работы планировщика, можно сказать, что долгосрочное планирование выполняется сравнительно редко, среднесрочное несколько чаще. Краткосрочный планировщик, обычно работает, определяя, какой процесс или поток будет выполняться следующим. 

####Виды планирования:
  * Долгосрочное — между рождением и готовностью (запуск процесса влечёт за собой требование процессорного времени и памяти)
  * Среднесрочное — Решение о добавлении процесса к числу процессов, полностью или частично размещенных в основной памяти. Сбрасывание из оперативной памяти не скоро выполняющихся процессов.
  * Краткосрочное — между готовностью и исполнением. Решение о том, какой из доступных процессов (потоков) будет выполняться процессором следующим. 
  * Планирование доступа к внешним устройствам.

// хуйнуть картинку из дока



---
## 15.  Критерии эффективности и свойства методов планирования процессов, параметры планирования процессов.
Для каждого уровня планирования процессов можно предложить много различных алгоритмов.
Выбор конкретного алгоритма определяется классом задач, решаемых вычислительной системой, и целями, которых мы хотим достичь, используя планирование.

#### Критерии:
1. __Справедливость__ - равномерно раздавать ресурсы всем потребителям.           
    * Утопическое понятие.
    * Противоречие эффективности.
    * Гарантировать каждому заданию или процессу определенную часть времени использования процессора в компьютерной системе, стараясь не допустить возникновения ситуации, когда процесс одного пользователя постоянно занимает процессор, в то время как процесс другого пользователя фактически не начинал
выполняться.
2. __Эффективность__ - постараться занять процессор на все 100% рабочего времени, не позволяя ему простаивать в ожидании процессов, готовых к исполнению.
3. __Полное время выполнения__ - время от того как процесс впервые попал в готовность до того, как он завершился.
4. __Время ожидания__ - сократить время, которое проводят процессы в состоянии готовность.
5. __Время отклика__ – минимизировать время, которое требуется процессу в интерактивных cистемах для ответа на запрос пользователя

#### Свойства алгоритмов планирования: 
 1. __Предсказуемость__ - если многократно на одних и тех же данных запустить алгоритм, то результат должен быть примерно одинаковым
 2. __Минимальные накладные расходы__ (В ОС нет сложных алгоритмов) - соотношения времени выборки процесса на исполнение и времени исполнения должны быть существенны.
```
Если на каждые 100 миллисекунд, выделенные процессу для использования процессора, будет приходиться 200
миллисекунд на определение того, какой именно процесс получит процессор в свое распоряжение, и на
переключение контекста, то такой алгоритм применять не стоит.
```
3. __Масштабируемость__ - алгоритмы не должны терять работоспособность при увеличении нагрузки.

#### Параметры планирования 
Параметры планирования – то, что мы знаем о системе и процессах , для того, чтобы планировать.
##### Статические параметры
На этапе загрузки процесса появляются статические параметры
* Каким пользователем запущен процесс;
* Приоритет задачи;
* Сколько процессорного времени запрошено для решения задачи;
* Каково соотношение процессорного времени и времени, необходимого на операции ввода/вывода;
* Какие ресурсы, и в каком количестве необходимы (оперативная память, устройства ввода/вывода, специальные библиотеки).
##### Динамические параметры
Динамические параметры появляются после первого исполнения
* Сколько времени прошло со времени выгрузки процесса на диск или загрузки его в оперативную память;
* Сколько оперативной памяти занимает процесс;
* Сколько процессорного времени было предоставлено процессу.


---
## 16.  Методы планирования без внешнего управления приоритетами (FCFS, RR, SJF), гарантированное планирование. Описание каждого метода, их достоинства и недостатки.

#### FCFS - First Come, First served
Простая аналогия - FIFO. Выстраивается очередь из процессов и каждый выполняется по порядку.

Такой алгоритм выбора процесса осуществляет невытесняющее планирование. Процесс, получивший в свое распоряжение процессор, занимает его до истечения текущего CPU burst(Время на процессоре) . После этого для выполнения выбирается новый процесс из начала очереди.

##### Пример:
// Вставить картинки

##### Преимущества
* Прост в реализации.
##### Недостатки
* Время работы алгоритма для конкретной очереди процессов зависит от расположения процессов в очереди. 


#### RR - Round Robin 
##### Описание
По своей сути, алгоритм является модификацией FCFS, он реализован  в режиме вытесняющего планирования. 

Принцип работы можно представить, если вообразить колесо обозрение, в котором каждая кабинка - это процесс и она проходит через нижнюю точку - процессор на определенный квант(промежуток) времени. Пока кабинка проходит над процессором, она может его использовать, чтобы исполнится.

Говоря, как еблан, каждому процессу в очереди дается время на процессоре (заранее выбранный квант времени), если он выполнился - сьебал из очереди и пошел следующий процесс, не успел - пошел в конец очереди заново ждать и идет следующий процесс.

##### Пример:
// Вставить картинки

##### Преимущества 
* Простота реализации
* При правильно подобранном кванте времени, выдает оптимальный результат
##### Недостатки
* При очень больших квантах времени, когда CPU burst меньше его, алгоритм вырождается в FCFS.
* При очень маленьких квантах времени появляются накладные расходы на переключения контекста, которые значительно снижают производительность системы.

#### SJF - Shortest Job First
##### Описание
Мы уже заметили, что если в алгоритмах FCFS и RR процессы с меньшим CPU burst стоят в начале очереди, то производительность алгоритма возрастает.

Давайте представим, что мы знаем у каждого процесса CPU burst, тогда мы можем на текущей итерации выбрать процесс, который стоит не в начале очереди, а с минимальным CPU burst, а если таких процессов несколько, то выбор среди них можно произвести с помощью FCFS (квантование при этом не выбирается). 

__SJF-алгоритм краткосрочного планирования может быть вытесняющим и невытесняющим.__


##### Невытесняющий SJF 
Процессор предоставляется избранному процессу на все необходимое время, независимо от каких-либо событий, происходящих в системе. 
// Пример
Можно сказать, что алгоритм невытесняющего SJF является оптимальным среди невытесняющих алгоритмов с точки зрения минимизации среднего времени ожидания.

##### Вытесняющий SJF
Учитывается появление новых процессов в очереди готовых к исполнению (из числа родившихся или разблокированных) во время работы выбранного процесса. Если CPU burst нового процесса меньше, чем остаток CPU burst выполняющегося процесса, то исполняющийся процесс вытесняется новым.
//пример


// тут должна идти хуйня с планированием, но я нихуя не понял


##### Преимущества
* Самый оптимальный алгоритм среди невытесняющих
* Показывает хорошие результаты при вытесняющем планировании
##### Недостатки
* Сложность в реализации
* Неопределенность при выборе очередного процесса из-за неточности CPU burst
* Может проявляться голодание в вытесняющем SJF, если постоянно добавлять процессы  маленьким CPU Burst




---
## 17.  Приоритетное планирование с внешним управлением приоритетами, многоуровневые очереди. Описание методов, их достоинства и недостатки.

**Приоритетным планированием** называется планирование, при котором каждому процессу присваивается определенное числовое значение – приоритет. 

Приоритет может задаваться как внутренними критериями системы (например, длительность CPU burst для SJF), так и внешними по отношению к системе. 

- **Внешние критерии** чаще всего являются важность процесса для пользователя (или важность пользователя) или количество профита, полученного за выполнение процесса (например, в денежном эквиваленте). Например, процесс, запущенный пользователем “администратор” имеет приоритет выше процесса “рядового пользователя”. Или процесс, за выполнение которого заплатили больше денег, будет дольше занимать процессорное время.

  **Достоинства:**
  

  **Недостатки:**

- **Многоуровневые очереди** были придуманы для более гибкого планирования работы процессов. С помощью таких очередей процессы можно разбить на группы, группе дать свой приоритет и пока в группе с более высоким приоритетом есть процессы для исполнения, процессорное время не будет передано процессам из группы с более низким приоритетом. 

    Получается, что каждая группа является отдельной очередью, при этом сами по себе группы-очереди находятся в одной большой очереди из групп.

    **Достоинства:**

    **Недостатки:**



---
## 18.  Организация планирования процессов в ОС семейств Microsoft Windows
        Егор
---
## 19.  Принципы работы планировщиков O(1) и CFS в операционных системах GNU/Linux.
        Егор
---
## 20.  Взаимодействие процессов. Условия взаимоисключения и прогресса. Понятие критической секции. Голодание процессов.
---    
####    Типология процессов.
         Процесс – это некоторая деятельность, связанная с исполнением программы на процессоре.
        При исполнении на центральном процессоре чаще всего различают:
        1. Порождение (подготавливаются условия для первого исполнения на процессоре)
        2. Активное состояние (программа исполняется на процессоре)
        3. Ожидание (программа не исполняется на процессоре по причине занятости какого-либо требуемого ресурса)
        4. Готовность (программа не исполняется, но для исполнения предоставлены все необходимые в текущий момент ресурсы, кроме центрального процессора)
        5. Окончание (нормальное или аварийное окончание исполнения программы, после которого процессор и другие ресурсы ей не предоставляются)Процесс находится в каждом из своих допустимых состояний в течение некоторого времени, после чего переходит в какое-то другое допустимое состояние. 

## 21.  Алгоритмы реализации взаимоисключений. Формальное описание алгоритмов, их недостатки.
---     хуй
## 22.  Семафоры Дейкстра. Решение проблемы «производитель-потребитель» с помощью семафоров.
---     хуй
## 23.  Проблемы взаимодействующих процессов. Проблема обедающих философов, проблема писателей и читателей.
егор
---
## 24.  Тупики. Условия возникновения и методы борьбы с тупиками.
## Тупики
* Может быть такая ситуация
* ![img](images/../imgs/Screenshot%202021-01-13%20at%2015.25.37.png)
  * Процесс 1 должен для своей работы использовать ресурс 1 и ресурс 2, причем его код написан так, что его критические секции имеют пересечение
  * Процесс 2 должен для своей работы использовать ресурс 1 и ресурс 2, причем его код написан так, что его критические секции имеют пересечение
  * В начальный момент времени ресурс 1 и 2 были свободны, и оба процесса их захватили, в какой-то момент времени, процесс Р0 решил, что ему нужно взять ресурс 2, но сделать он этого не может, поэтому он просто остановил свою работу
  * Процесс Р1 пользовался ресурсом 2 и в какой-то момент решил использовать ресурс 1, но ресурс 1 занят процессом Р0, и этот процесс тоже остановил свою работу
  * Не один из этих процессов не может продолжить работу и не может отдать ресурс обратно
  * Таким образом мы получаем бесконечный тупик

#### Проблема обедающих философов
* Есть стол за котором сидят 5 философов
* Перед каждым стоит тарелка со спагетти
* Философ может есть спагетти только 2 вилками
* вилок на столе ровно 5
#### Решение проблемы обедающих философов
* Выделим несколько состояний для философов
  * Может размышлять
  * Может находиться в состоянии голодания
  * Может есть

1. Каждый берет левую потом правую вилку
   * Может получиться так, что все философы поднимут левую вилку одновременно, то произойдет тупик
2. Возьми левую вилку
   1. Попытайся взять правую
   2. Если правую взять не удалось, положи обратно левую
   3. После чего попробуй повторить
   4. Таким образом получается live - lock
3. Можно сделать так же как во 2 случае, но ждать рандомно перед тем, как повторять действия
   1. Таким образом нет никакой гарантии, что процессы не выберут одинаковое время и не попадут в live - lock или dead - lock
4. Наличие официанта
   1. Кто-то должен разрешать и запрещать есть этим философам

#### Условия возникновения тупиков
1. Mutual exclusion - условие взаимоисключения
2. Условие ожидания ресурсов - hold and wait
   1. Если процесс взял ресурс, он имеет право его не отдавать и при этом просить некоторые следующие ресурсы
3. Условия не перераспределяемости -  No Preemtion
   1. Если мы выделили процессу ресурс, то мы не можем забрать его обратно
4. Условие кругового ожидания - Circle wait
   1. Процессы относительно 2 или более ресурсов встали в кольцевое ожидание

#### Как решить проблему возникновения тупиков
1. Игнорировать проблему - так как вероятность возникновения тупика очень маленькая
2. Пытаться предотвратить тупики
   1. Сделать организацию ос таким образом, что вышеупомянутые 4 условия никогда не выполнятся одновременно
3. Обнаружение тупиков и восстанавливаем после них
   1. Обнаруживаем тупик после того как он произошел
   2. После этого за счет каких-то механизмов восстанавливаем работоспособность (механизмы эти рассматривать не будем)

__Таким образом поняли, что наиболее эффективно будет пытаться предотвратить тупики__
__Но как ?__
* Mutal exclusion
  * В некоторых ситуациях можно разрешать 2 процессам пользоваться 1 неразделяемым ресурсом
* Можно нарушить условие hold and wait
  * Мы разрешаем процессу только в самом начале или когда он 1 раз просит тот или иной ресурс, сразу же просить все ресурсы от него
    * И либо даем ему все ресурсы сразу
    * Либо отказываем в даче ресурсов
  * Это можно использовать там, где не очень большое количество ресурсов
* Можно нарушить принцип отсутствия перераспределения
  * По какому-то принципу отбирать недостойный процесс и забирать у него ресурс, предварительно забуферизовав этот ресурс
  * Прямо как при прерывании
* Можно попытаться нарушить круговое ожидание
  * Можно пронумеровать все ресурсы
  * Мы разрешаем процессу брать ресурс только с номером, который выше чем номер самого ресурса

##### Проблема читателей и писателей
```
P0 -----(r)     --------(r)
P1      -------(r)
P2   ----(w)-------(w)
```

* Проблема в том, что процесс записи может уйти в вечное голодание из-за того, что постоянно будут появляться новые процессы на чтение
* __Решение__
  * Уложим требования на запись и чтение в очередь
---
## 25.  Принципы управления памятью вычислительной системы. Виртуальная память и преобразование адресов.

егор
Из состояния ожидание процесс попадает в состояние готовность после того, как ожидаемое событие произошло, и он снова может быть выбран для исполнения. 

Наша новая модель хорошо описывает поведение процессов во время их существования, но она не акцентирует внимания на появлении процесса в системе и его исчезновении.

#### Пятиуровневая модель
Рождение – растянутый этап, на котором ОС решает, стоит ли рождать этот процесс. На этом этапе у процесса нет PCB. 
* После рождения процесс переходит в статус «готовность». 
* Из готовности планировщик переводит процесс в статус «исполняется». 
* После исполнения процесс либо завершается, либо отправляется в ожидание.
* За состоянием ожидания следит определенный процесс ядра ОС. 
* После прерывания ожидания процесс переходит в статус готовности. И снова к исполнению. 
* Завершение – растянутый этап завершения процесса: освобождения памяти, нахождение родителя. процесс находится в завершении значительное время пока ОС в поисках. 

![img](сюда вставить)

Теперь для появления в вычислительной системе процесс должен пройти через состояние рождение. При рождении процесс получает в свое распоряжение адресное пространство, в которое загружается программный код процесса; ему выделяются стек и системные ресурсы; устанавливается начальное значение программного счетчика этого процесса и т. д. Родившийся процесс переводится в состояние готовность. При завершении своей деятельности процесс из состояния исполнение попадает в состояние закончил исполнение.

#### Семиуровневая модель
Шаги: пятиуровневая модель + исключительная ситуация + зомби-состояние (только для Linux).
* Если в процессе исполнения возникает ошибка, процесс отправляется в исключительную ситуацию. После решения ошибки из исключительной ситуации процесс получает статус готовности.
* Выход из зомби процесса не всегда возможен.

![img](сюда вставить)

---
## 26.  Методы распределения оперативной памяти без использования внешней памяти.

- ***Распределение памяти фиксированными разделами***
- ***Распределение памяти разделами переменной величины***
  
  Система заранее не делит память на разделы. По мере поступления задач выделяется необходимая память. После того, как задача завершилась, она удаляется и на ее место помещается новая задача. 
  
  На схеме видно, что по мере выгрузки процессов из памяти и загрузки новых появляется много небольших свободных зон, в которые уже не могут поместиться новые процессы. Это явление называется внешней фрагментацией.

  [img]('..imgs/26.png');

  

- ***Перемещаемые разделы***

  Суть этого метода заключается в том, что разделы динамически распределяются в памяти так, чтобы образовывалась одна непрерывная свободная область памяти. Уплотнение может происходить при каждом завершении процесса, или если новому процессу не нашелся достаточно большой свободный участок.

  Хоть память и используется эффективно, но алгоритм требует больше времени для устранения фрагментов, что перевешивает преимущество данного метода. 


---
## 27.  Страничная организация виртуальной памяти. Вычисление физических адресов при страничной организации виртуальной памяти.
---
## 28.  Методы оптимизации потребления ресурсов при страничной организации виртуальной памяти. Сегментно-страничная организация виртуальной памяти.
---
## 29.  Методы организации хранения данных в файловых системах: непрерывная последовательность блоков, связный список, таблица размещения файлов.
---
## 30.  Методы организации хранения данных в файловых системах: индексные дескрипторы.
---
## 31.  Журналируемые файловые системы. Назначение и виды журналов.
---
## 32.  Обоснование необходимости и принципы построения распределенных ОС.
---
## 33.  Алгоритмы управления памятью в распределенных ОС. Их преимущества и недостатки.
---
## 34.  Методы управление файлами и каталогами в распределенных ОС. Их преимущества и недостатки.
---
## 35.  Синхронизация времени в распределенных системах. Метод Лампорта для синхронизации времени.
---
## 36.  Технологии виртуализации. Виды виртуализации: эмуляция аппаратуры, полная виртуализация, паравиртуализация, виртуализация уровня ядра операционной системы. Их достоинства и недостатки.
---
## 37.  Архитектура облачных систем. Основные компоненты, их назначение и способы взаимодействия. Принципы мониторинга и управления производительностью в облачных системах.

# Лекция 5

## Управление процессами
* Мы поговорили об эволюции операционной системы
* Тут мы разбираем работу подсистем

## Система управления процессами - 1 тема
### А что такое процесс ?
> Совокупность набора исполняющихся команд ассоциированных с ним ресурсов и контекста исполнения находящихся под управлением операционной системы
* Совокупность набора исполняющихся команд:
  * Последовательный выбор и исполнение команд из некоторого набора
* Ассоциированных с ним ресурсов:
  * Каждый процесс обладает своим собственным адресным пространством. То есть это ассоциированеы с ним ресурсы.
* И контекста исполнения:
  * Проуессы могут перключаться. Они могут быть в процессе ожидания и в процессе действия. Нам необходимо восстанавливать регистры при переключении из одного режима в другой. 
* Находящихся под управлением операционной системы
  * Процесс для операционной системы может быть только пока она может им управлять. Создав процесс, операционная система создает структуру для управления процессом.

### Как соотносить понятие процесс и программы или приложения
> Процесс не тождествено равен какой-то программе
> Программы могут испольщовать параллелизм. То есть мы можем зщапустить много процессов под однйо программой.

* Процессы должны быть изолированы друг от друга
  * Есть растровая картинка и мы хотим ее поменять
  * Было бы классно обрабатывать эту картинку параллельно двумя картинками. Но мы не можем это делать, так как процесысы должны быть изолирован ыдруг от друга.
* Прилдумали делать в прцессе разные команды и переключаться между наборами комманд
#### Такая пара получила название __поток (thread)__

### Процесс может включать в себя множество потоков
* Каждый поток имеется разный набор команд
* Но все потоки имеют одно адрессное пространвстов
#### Стали говорить, что процесс это набор ресурсов
* в любой оси запуск программы это запуск процесса и как минимум одного потока
* В операционной системе потоки управляют выдачей ресурсов
  * Это привело к таким сложносятм,
  *   Если мы написали многопточное приложение
  * Тогда перключение между потоками можно жедать только через режим ядра
  * Тогда нам надо переключатся а жэто затратно
  * 2 часть проблеммы это то, что надо иметь алгоритмы по перключению медлу потокми с точки зщрения очереди.
  * Может возникнуть проблема в том, что операционная система будет перкляюваться междду потоками не так как мы этого хотим и теряется выгода в использовании мульипоточности
### Идея - А нельзя ли нам делать многопоточность на пользовательском уровне вне ядра операционной системы
### Появился fiber (волокно или __green threads__)
* Это тоже разные наборы команд и контекстлв
* Но упавление перклюяением между ними берет на себя код потока
* Таким образом мы получаем упарвление многопоточностью на пользщовательском уровне
#### В чем тут минусы
* Мы должны сами управлять алгоритмами переключения между fibers
*  Появилась проблема того, что мы не имеем таймера переключения, когда работаем с fibers
*  Появилось решение Кооперативной многозадачности
   *  Само волокно в какой-то момент времени отдаст управление волокну друномц или волкну диспетчеру
      *  Если произойдет сбой где-то то мы не дойдем до конца выполнения
      *  Таким образззом fibers используют не всегда.

### Возникла прблема
* У нас есть бразуер - там много вкладок - сделаем каждую вкладку отдельным потокм
* Сложно обеспечить безопасность, так как потоки имеют общую область памяти
* Сложно обеспечить надежность
Тогда решиили на вкладку отдавать порцессы
* Проблема
  * Теряется много ресурсво

### Появляется новыц уровень иерархии - job (в windows)
Набор квот для тех или иных процессов
* Можем установить квоту на суммарное испольщование процессорного времени, памяти, сетевого тарфика и так далее...

### Как операционная система выполняет процессы?
* Создание 
  * Процессы и потоки создаются
* Обеспечение ресурсами
  * Нужна бужет память
* Изоляция
  * Процессы должны быть изолированны
* Планирование
  * Решение о том, в каком порядке и обьеме пердоставлять потоки или проццессу доступ к ресурсам
* Диспетчеризация
  * Исполнение нащего плана, переключение процессов между состояниями
* Взаимодействие
  * Что-то, чтобы процессы, преодолевая изоляцию друг с другом, могли взаимодействовать друг с другом (наприемр конвеер в shell)
* Синхронизация
  * Процессы могут начать конфликтовать между собой за ресурсы.
* Уничтожение
  * Уничтожить процесс и почистить память

### Как операционная система это делает ?
#### Создание процесса
* Термин - роождение процесса 
  * Любой процесс пораждается другим процессом (родительским)
* Кто породил 1 процесс ?
  * А это мы узнаем на 3 курсе (p.s init)
* Процедура порождение процессов
  * Иерархия процессов
  * Структура данных, которая будет характеризовать процесс
    * Там будет информация по идентификации процесса 
      * Есть как минимум один  - PID (process id - число)
      * Есть Parent PID - родительский процесс
      * UID - (User ID) - идентификатор пользователя, который этот процесс запустил. Это нужно для того, чтобы процессу давались права, ассоциированные с правами доступа пользоватеся, который этот процесс запустил. 
      * GID - (Group ID)
    * Информация по состоянию - status
      * Каждый процесс должен иметь какой-то статус, чтобы сохранять инвариант тех действий, который с этим процессом можно делать
    * История
      * Сколько раз просил такую-то операцию
      * Сколько процессорного времени занял
      * Сколько раз переключался
      * И там далее в зависимости от версии системы...
  * > То есть создание процесса - это создание структуры данных, описанной выше
  * Как создать эту структуру данных ?
      * В LINUX процессы параждаясь, образуют дерево процессов ациклическое и направленное. Корень этого дерева будет такой:
        * У него PID = 1
        * PPID = 0 (но это уловка, у него просто нет )
    * Порождение идет за счет клонирования всего кода родительского процесса в дочерний через __fork()__
      * Родительский процесс получит PID ребенка
      * Ребенок получит уникальный PID и PPID
      * Вся остальная структура о дочернем процессе скопируется со структуры родительского процесса. Что это даст ?
        * Дочерний процесс унаслежует права и возможности родительского процесса
    * Дальше выполняется системный вызов exec и мы заменяем код в дочернем процессе на тот код, который был указан в программе через exec.
    * Когда процесс завершился, он сообщает своему родителю о статусе своего завершения. Через SIGCHLD.
      * Это дает нам возможность через wait() прочитать код возрата ребенка и выолнить какие-то дейтсвия в щавимисомти от этого кода
    * Может возникнуть ситуация, когда родительский процесс некорректно завершится(неожиданно)
      * Дочерний процесс осеротел и он будет тут же детьми корневого процесса (init в Linux)
      * Это сделано для того, чтобы не нарущадась деревовидная структура
    * Может возникнуть ситуация зомби процесса.
  * Как создать эту структуру в windows ?
    * У нас есть диспетчер процессов, который пораждает все процессы и является посредником между родителями и детьми. Создает детей для родителей. 
    * Тут может быть проблема, заключаящаясь в том, что мы можем дать дочкернему процессу более высокие права нежели чем у родительского.


#### Обеспечение ресурсами
* Оно происходит в разные моменты
  * Когда процесс создается, он уже получает какие-то ресурсы. Такие ресурсы называ/тся статическими.
  * Но есть динамические ресурсы - в момент выполнения ресурса
    * Процессорное время
    * Дополнительная память
    * Открытие дополнительных файлов
* Есть различные механизмы по распределению ресукрсов, которые мы рассмотрим в будущем

#### Изоляция
* В будущем мы погорим о том, как правильно обеспечивать распределние памяит.

#### Планирование
* Это отдельный процесс, ктоорый так же будет рассмотерн на отдельной лекции. 
  * Давать ли процессору процессорное время ?
  * Давать ли процессору память
  * Давать ли процессу возможность рождаться ?
  * Даваит лл процессу доступ к портам ?
  * И так далее ...

#### Диспетчеризация
* Это процедура связанная с переключением процессов
  * Самая простая диспетчериация - это когда мы меняем процесс, который в данный момент выполняется на cpu. Такая операция выполняется в 3 шага.
    * 1. Сохраняем регистыр 1 процессора
    * 2. Загружвем в регистры процесса контекст регистров другого процесса
    * 3. Потом меняем их состаяние.
  * Эта операция должна быть атомарна
    * Нужно ставить процессы из ожидания в действие и обратно
  * Между какими состояними может происхожить переключения этих процессов ?
  * Эти состояния мы изучим в следуюющей лекции.

#### Взаимодействие
* Мы не будем много затрагивать эту тему в нашем курсе
#### Синхронизация
* Так же будет отдельная лекция

#### Уничтожение
* Может получиться так, что процесс завершился, но операционная система еще не записала данные от этого процесса в адресное пространство. 
  * В таком случае операционня систем должна быстро записат эти данные, чтобы потом была возможност ь их удалить. 
  * Может быть блокирка ресурсов для процесса, нужна такие блокировки снимать
  * Родительский процесс должен получать код возрата дочернегопроцесса. 


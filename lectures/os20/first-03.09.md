# Лекция 1

## Этапы изучения
* **1 блок**
  * Функциональная архитектрура
  * Архитектура ядер
  * Процессы, потоки, поговорим про жизненный цикл процессов
  * Задачи планирования
  * Алгоритмы планирования
  * Очереди и многоуровневые очереди
  * Как это все реализованно в **windows** и **linux**
* **2 блок**
  * Память
  * Раслперделнные операционные систем, вирутальные машины, облачные хранилища.

## Литература
* [Тоненбаум - cовременные операционные системы.](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjBnZiUvM_rAhVt-yoKHakdDywQFjAAegQIARAB&url=https%3A%2F%2Fwww.ss-20.ru%2Findex.php%3Faction%3Ddlattach%3Btopic%3D455.0%3Battach%3D2290&usg=AOvVaw3HLpFcrRpY3YUHx1ikAVVh)
* [Дейтел - Операционные системы](https://www.studmed.ru/lorin-g-deytel-hm-operacionnye-sistemy-glavy-1-3_767af52fbb3.html)
  
## Лабораторный практикум
* Опора на администрирование, чтобы мы понимали как устроено что-то в OS
* Работы будут в **linux**, будет предложено окуржение **centos**
* Лучше использовать **виртуальную машину**

### Лабораторная работа 1 - bash и shell
* Знакомство с **bash**
* Написание **shell** скриптов
* Регулярные выражения

### Лабораторная работа 2 - мониторинг ресурсов
* Данная лабораторная работа покажет, каким образом можно отслеживать состояние системы.

### Лабораторная работа 3 - управление процессами
* Как процессы могут обмениваться данными

### Лабораторная работа 4 - управление памятью

### Лабораторная работа 5 - работа с файловой системой
* Жесткие и мягкие ссылки
### Лабораторная работа 6 - windows
* Работа с написание скриптов
* Упарвление в **windows**
* Сравнение администрирования в **windows** и **linux**

## Аттестация
  * 60 баллов (вместе с личностными качествами)
  * 2 рубежные работы в сумме 20 баллов
  * Устный экзамен на 20 баллов 

# Эволюция понятия операционной системы - 1 тема
* Как появлялись основные функции os
* Поговорим о технической архитектуре и архитуектруе ядра
* Посмотрим вглудь памяти

### Операционная система
**базовое системное ПО, управляющее работоц вычислительного узла и являющееся посредником между программным обеспечением, аппаратным обеспечением и пользователем.**

* Сначала комьютеры работали на **архитектуре Фон Неймана**
* Суть данной архитектуры заключалась в том, что **cpu** был связан с **ram**, **input**, **output** и **storage**.
* Проблема **архитектуры Фон Неймана** заключалась в сложности параллельного выполнения программ, так как было сложно достичь синхронизации данных на входе и выходе

![img](/lectures/os20/images/lecture1/fon_neyman.png)

### Задача - распараллелить поцессы, которые проходят через cpu
### Решение - программа диспетчер
* Возьмем фрагмент памяти, в который заложем часто повторяющиеся фрагменты кода и будем их вызывать
  * Проблемы:
    * Нужно сохрнаять адреса, где хранятся эти компоненты
    * Нужно системное по, которое будет делать линковку основной программы и подпрограмм

### Задача - оптимизация взаимодейтсвия с утройствами ввода вывода и хранения

* Все пути идут через процессор -> (**при архитектруе Фон Неймана**)
* Проблема - мало **ram** для хранения огромного количества данных, если временные данные хранить в **ram**
* Проблема - процессор при такой работе работает не рациоально, потому что выполняет простые операцции, которые не используют всю его мощь

##### Таким образом был придуман принципы распараллеливания процессов

При параллельном выполнении процессов возникают сложности:
* Хранилище не гарантируют нам быстрый доступ к данным, из-за этого мы не знаем, когда кончится операция ввода-вывода
* Оснавная проблема в том, что таким образом нам сложно синхронизировать параллельность разгрузки подгрузки памяти
### [Концепция spool](https://www.geeksforgeeks.org/what-exactly-spooling-is-all-about/)
![spool scheme img](/lectures/os20/images/lecture1/what-is-spooling-in-operating-system-example.png)
* Добавили контроллер, который имеет мало возможностей, связь с **input**, **output**, **cpu** и **ram**
* Этот контроллер передает сигнал процессору, который говорит, когда можно обрабатывать данные, а в какой момент программе нужно перйти в режим ожидания.
#### В общем, этот контроллер прерывает ввод и вывод, что позволят обеспечить синхронность при параллельном выполнении программ

### Задача 3 - Мультипрограммность
* Писать программы однму тяжело
* Тяжело линковаться к готовым программам
* Появляется пробоема локальной необходимости в данных
* Таким образом программа разделяется на компоненты, в этой ситуации появлятеся пониятие *пакет*
* Пакет - это множество программ и данных(например констант)
* Теперь в память нужно загружать пакет, но каким образом?
* Появилась программа по загрузке пакетов, появились механизмы планирования.


#Мультипрограммные OS
### Мы обеспечиваем параллельную подгрузку пакетов за счет переключения между загрузкой пакетов
Проблемы: 
* Нужны адреса для пакетов
* Нужно знать прямые адреса
* Как осуществлять переключение между программами ?
* Как распередлять ресуры ?
* Как делать точку возрата ?
* Ошибка в коде может привести к выходу за переделы памяти и в последствии нарушению целостности данных

## Следующая лекция будет про Мультипрограммность

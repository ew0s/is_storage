# Лекция 2

## Мультипрограммные операционные системы
### Задача: программы должны разделять время cpu
### В чем необходимость ?
* Наши приложения обладают различным поведением, соответственно, они с разной нагрузкой воздействуют на **CPU**
* Параллельность может стать псевдопараллельной, потому что может меняться поведение программы в процессе ее выполнения. Нам нужно избавиться от псевдопараллельности.
    > Было бы здорово иметь много программ в памяти и грамотно взаимодействовать с ними

### Задача - обеспечение времени разделения процессора
> **Будем рассматривать только те процссоры, которые будут 1 ядерными >> все процессы должны будут считаться на 1 ядре**
#### Что нужно для разделения времени процессора?
  * Есть 2 процесса. Будем чередовать их выполнение.
  * Как сделать переход ?
  * Нужно запомнить место, где процесс остановился.
    * Сохранить значения регистров.
    * Загрузить данные в регистры для нового процесса **(это требует врмени)**
#### Как процессу остановить другой процесс?
* Решение на аппаратном уровне (как контроллер для spooling'a)
* Добавили таймер, который через равные промежутки прерывает выполнение процессов.
* Прерывание - это передача управления процессами диспетчеру прерывания
![timer_img](images/lecture2/func.jpg)
#### Как разделять память ?
* Когда мы компилируем **по**, мы работаем с адрессами в памяти так как используем низкоуровневый язык.
* В момент запуска программы, мы не можем знать, где операционная система выделит память под наше **по**.
* **Как узнать адреса, где будет храниться программа в момент разработки программы ?**
#### Решение: механизм - виртуальная память 
> Это абстаркция, которая позволляет нам в вирутальном адресном пространстве осуществлять перевод виртуальных адресов в физические (то есть это нужно для того, чтобы мы могли перенести адреса, которые мы создавали при проектировании преобращовывать адресса)
#### 3 Задача - обеспечние защиты программы от действия других программ
* Надо защищать адресное пространствох
  * В результате ошибки программиста, мы можем выйти за пределы адресного пространста, если мы что-то туда запишем, возникнет сбой
#### Механизм защиты памяти - аппаратное решение
* Он будет проверять права доступа для записи или чтения
* **Прервыание по защите памяти**
  * Простое рещение - уничтожить процесс, котторые пытается сделать что-то противозаконное
  * Но через некоторое время, мы поймем, как рещить эту проблему
* Такие механизмы появляются мног где
  * Например у нас есть принтер, мы передали управление им программе, мы прервали ее, передали упраление 2, 1 ждем 2, прервали 2, непонятно как дальше идти
  * Как узнать, что программа 1 решила что-то печатать ?
#### Задача планирования выполнения программ
* Необходимость в планировании выполнения пакетов
  * Мы могли выбирать один из очереди и отправлять на выполннеи
* Ситуация поменялась - теперь надо разделять процессорное время:
  * Задача планирования становится многофакторной - Я хочу много что оптимизировать
  * В этой ситуации планировщики усложняются
  * Но их нельзя сильно усложнять
  * Поэтому появляется рещения, которые мы 

## Задча по синхронизации
* Нужны механизмы, которые обеспечат межпроцессорное обеспечение
## Задача доступа иформации на внещнем хранилище
* При мултипрограммности поялвется проблема контрлируемого доступа у данным в хранилище
  * нужно обесепчить очередь
  * Нужно праивльно выбрать адреса в храгилище 
    * Для ускорения ликовыки например
  * Можно хранить программы в библиотке на хранилизе и подгружать их
    * Нужна особая адрессация
  * Появлется механизм фалово - котологовой системы
    * Даем уникальные имена
    * Группируем их в дирректории
    * Выстраиваем иерарзию между ними
    * Получаем контролируемый доступ к данным в хранилище

## Что мы иммеем - появляется термин виртуальная машина
* На этапе 60 годов это значит, что каждый процесс выполняется в рамках какой-то операционной системы
* Эта концепуиця приводит к появлению независимомти оси от программного обеспечения

Появлется мехаизм SyScall - генерируется ситемный вызов, ось принимает рещение по пердоставление ресурсов

Между пользоватеелм и осью появляется пользовательский интерфейс

## Какаая ось первая - в 1963 ось MCP (main controll programm)

# 3 Этап - Сетевые операционные системы
* Проблемы
  * Много данных
  * Машины очень дорогие
  * Количестов потребителей растет
Возникает разделение машинного времени среди пользователей
  * Накладные расходы
  * Ввод и вывод - узское место. Много программ, один оператор, который вводит программ в компьютер -> снижение эффективности использоавния компьютера
## Решение - Удаленные терминалы
* Обьеднием входдные выходные устройства
* Звоним в вычислительный узел и просим что-то вычислить
* Появляется многотерминальнсоть прблема
  * Безопасность - нет оператора, который контролирует ввод и вывод, можно внести вирус
    * Появляется мезанизм аутефикации и авторизации
    * Водится понятие пользователя и пользовательский режим
* Появляется удаленное взаимодействие между различными вычислительными узлами
  * есть 2 города с машинами, появляется механизм по обмену данными между машиннами
  * Поялвялютяс распределнные операционные системы

# 4 Этап - открытые операционные системы
* Предпосылка
  * проблема переносимости кода
  * Нужна ось, которая может запускаться на различным компьютерах
* Проблемы:
  * Нужна ось, которая сама по себе будет рабоать на языке выского уровня
    * Пояляется проблема курицы и яйца
  * 
* Bella boretlis - великая компания
  * Они создают Unix и C
  * В 1969 году выходит операционная система unix (UNICS), написанная на асемблере
  * На следующем этапе эта команда разрабытывает язык би и unix переписывается под нее
  * Выходит 3 редакция с компилятором си 
  * Выходит 4 редакция с ядром, написанным на си
  * Выходит 5 редакция, которая полностью написана на си
  * Таким образом появилась универсальная операционная система **Unix**

## Как появился Linux
* Появился проект GNU
  * Разрабатывают компилятор GCC
  * Разрабатывются утилиты и мудли на Си
  * Нужно написать ядро
    * Студент Линукс Торвальдс читает Тоненбаумана и разочаровывается в его оси и в 1991 выкладывает в окрытый доступ ось, которая содержит ядро, которое монолитно
    * Тоненбаумен критикует linux, говоря, что архитекутра 86 скоро умерт, а linux написана только под нее.
    * Linux интегрирует Linux с GNU. Так и появилась GNU Linux.

# Следующая лекция - функциональная архитекутра, какие виды бывают, перейдем к технической архитектуре. Далее перейдем в управление процессами, памятью и друшими операцилнными процессами 
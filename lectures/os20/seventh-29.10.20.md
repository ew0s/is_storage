# Лекция 7
## Планирование процессов

Планирование зависит от понятия горизоант планирвоания
* Короткосрочное планирование
* Долгосрочное планирование
* Среднесрочное планирование
* Среднесрочное планирование

Мы должны были определиться с критериями, свойствами и параметрами планирование. И опрделились с критериями и свойствами. 

---

## Параметры планирования
> Мы должны что-то знать об обьекте и на основании этих знаний принять решение как воздействовть на этот обьект

### Есть 4 класса параметров:
* Параметры системы
* Параметры процесса
* Параметры статические
* Параметры динамические

> Статические параметры с точки зрения планирования - это ограничения
> Динамеческие парметры - меняются во времени и характеризуют параметры во времени

* Статические параметры системы - это предельные ресурсы системы. То есть сколько у нас памяти, ядер, какая пропускная способность каналов.
* Динамические ресурсы системы - текущее среднее о количестве свободной памяти, какое среднее время процессора мы забираем. Они помогают оценить насколько эффективно мы используем систему.
* Статические параметры процесса
  * Права доступа
  * Могут быть приоритеты, то есть важность процесса - про это мы поговорим на следующих лекциях
* Динамические параметры процесса
  * Это то как он использует ресурсы. То есть сколько он в будущем будет потреблять ресурсов.
    * __CPU-burst__ - то есть сколько временных единиц будет исполняться процесс, если мы дадим ему возможность без прерываний работать на процессоре. 
  * Процесс чередует операции ввода - вывода 
    * __IO-burst__ - сколько процесс будет ждать операцию ввода - вывода

---

### В чем задача планирования ?
### У нас есть множество процессов, мы хотим так наложить графики параметров планирования процессов друг на друга, чтобы максимально использовать cpu, чтобы максимальное количество процессов были в состоянии исполнения, и чтобы максимальное количество процессов были в сосотянии ожидания ввода - вывода. 

---

## Алгоритмы планирования - дисциплины обслуживания очереди

#### Есть 2 класса алгоритмов планирования:
* Вытесняющее
  * Это когда есть механизм, который позволит прервать выполнение текщего процесса для того, чтобы передать ресурс следующему процессу. (Это может быть например из-за таймера или посылания сигнала процессу)
* Не вытесняющее
  * Если мы дали процессу выполняться, то он только сам может завершить или приостановить свое исполнение

#### Критерии сравннеия алгоритмов:
* Полное время исполнения - время, которое нужно для исполнения _*k*_ процессов.
* Среднее время исполнения - у каждого _*i*_ процесса можно выделить время, когда он мог бы уже исполняться до момента, когда он завершил исполняться. Если мы для всех процессов возьмем и усредним это время, то это и будет величиной среднего времни исполнения.
* Среднее время ожидания - сколько процесс в среднем находился в процессе ожидания.

### Алгоритм планирования - First Came First Served (FCFS) или FIFO
> Пусть есть 3 процесса

| processID | CPU-burst | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 |
| --------- |:---------:| - | - | - | - | - | - | - | - | - | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| p0        |13         |E  |E  |E  |E  |E  |E  |E  |E  |E  |E   |E   |E   |E   |E   |W   |W   |W   |W   |W   |
| p1        |4          |W  |W  |W  |W  |W  |W  |W  |W  |W  |W   |W   |W   |W   |W   |E   |E   |E   |E   |W   |
| p2        |1          |W  |W  |W  |W  |W  |W  |W  |W  |W  |W   |W   |W   |W   |W   |W   |W   |W   |W   |E   |

#### Если очередь выстроить от р0 -> р2 
* Полное время исполнения - 13 + 4 + 1 = 18
* Среднее время исполнения - (13 + 17 + 18) / 3 = 16
  * Для p0 = 13
  * Для p1 = 17
  * Для P2 = 18
* Среднее время ожидания - (0 + 13 + 17) / 3 = 10
  * Для p0 = 0 
  * Для p1 = 13
  * Для p2 = 17

#### Если очередь выстроить от р2 -> p0
* Полное время исполнения - 18
* Среднее время исполнения - 8
* Среднее время ожидания - 2

---

### Алгоритм планирования - Round Robin (RR, что в переводе на русский - Кругля карусель)
#### Идея
* Внутри карусели сидят процессы, и мы разварачиваем(условно) их к процессору и даем выполнится этому процессу опеределнное количество квантов тактов, затем делаем прерывание, и дает выполнться дургому процессу.

---

* При той же ситуации, что и в 1 алгоритме с худшим расположением очереди с тактом в 4 кванта:
  * Полное время исполнения - 18
  * Среднее время исполнения - (18 + 8 + 9)/3 = 11,7
  * Среднее время ожидания - (5 + 4 + 8)/3 = 5,7 
* При той же ситуации, что и в 1 алгоритме с лучшим расположением очереди с тактом в 4 кванта:
  * Полное время исполнения - 18
  * Среднее время исполнения - 8
  * Среднее время ожидания - 2

#### Проблема этого алгоритма заключается в том, что нам нужно подбирать количество квантов процессорного времени в 1 один такт в зависимости о входных данных (то есть в зависимости от размеров квантов, необходимых для выполнения процессов). Нахождение оптимального количество квантов - это достаточно сложная задача. Поэтому был разработан другой алгоритм.

---

### Алгоритм планирования - Shortest Job First (SJF)
#### Идея
* Может быть как вытесняющий, так и не вытесняющий алгоритм.
* Через некоторые кванты времени проверяется, и если есть более значимый процесс, ему отдается процессорное время.

#### Пусть k(квант) = 2; t0 - время появления процессов
* В 0 момент времени у нас есть только 2 процесса - р0 и р3
* Выполняем р3, потому что он требует меньше времени на выполнение - его CPU-burst теперь 3
* Произошло прерывание и появился процесс р1, мы видим, что он требует меньше всего времени на выполнение и выполняем его - его CPU-burst теперь 0 и он заканчивает свое выполнение.
* И так далее идем до тех пор, пока не выполним все процессы.


| processID | CPU-burst | t0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
| --------- |:---------:| -- | - | - | - | - | - | - | - | - | - | -- | -- | -- | -- | -- |
| p0        |6          |0   | W | W | W | W | W | W | W | E | E | E  | E  | E  | E  | -  |
| p1        |2          |2   | W | W | E | E | - | - | - | - | - | -  | -  | -  | -  | -  |
| p2        |7          |6   | W | W | W | W | W | W | W | E | E | E  | E  | E  | E  | E  |
| p3        |5          |0   | E | E | W | W | E | E | E | - | - | -  | -  | -  | -  | -  |

* Полное время исполнения - 18
* Среднее время исполнения - 8
* Среднее время ожидания - 2

#### Плюс этого алгоритма в том, что если вдруг придет какой-то процесс, который будет требовать меньше всего CPU-burst. То при прерывании алгоритм выберет именно этот процесс на исполнение. Таким образом не будет создаваться огромная очередь из процессов, которые требуют мало процессорного времени, а процессы с большим процессорным временем для выполнения, будут постепенно выполняться.
#### Минус этого алгоритма в том, что мы тратим время на переключение, но это не самая большая проблема.
#### Самая большая проблема тут в том, что могут появиться голодающие процессы, которые будут получать мало процессорного времени.

---
### Алгоритм планирования - Гарантированное планирование

* $$Пусть~есть~N - это~количество~процессов~в~системе$$ 
* $$Пусть~есть~T[i] - это~время~сеанса~\textbf{i}~процесса$$
* $$Пусть~t[i] - время~исполнения~\textbf{i}~процесса$$
* $$t[i] ~ T[i] - это~формула~по~которой~распределение~ресурсов~происходит~справедливо$$
* $$Есть~R = \frac{t[i]}{\frac{T[i]}{n}} = \frac{t[i] * N}{T[i]} - каэффицент~справедливости$$
* Таким образом, процесс, который мы будем обделять, то есть не будем дават ему время на работу, будет иметь минимальный *_R_*
* Но как только мы начнем его выполнять, этот коэффицент начнет расти по сравнению с другими, и наш процесс в какой-то момент станет не хуже коэффицентов других процессов.
* После этого мы начнем выполнять другой процесс с самым маленьким коэффицентом справедливости.
* Стоит отметить, что выполнение процесса будет вестись в фиксированный квант времени, за счет этого мы обеспечим меньшую трату ресурсов на переключение между процессами.

#### Плюсы:
* Теперь все процессы будут выполняться действительно параллельно и пороано и голодающих процессов не будет. Так как у таких процессов всегда будет повышаться коэфицент справедливости.
* 
#### Минусы:
* С точки зрения эффективности мы проигрываем, потому что работаем относительно времени нахождения процесса в очереди. Таким образом процессы, которые требуют мало ресурсов, так же будут стоять без движения.
* Накладные расходы на сортировку массива коэффицентов, являющихся вещественными числами.
* Неустойчивость к взлому - если наш процесс будет долго простаивать без действия, его коэффицент справедливости будет самым низким, и операционная система будет проталкивать его в топ. Взломщик может этим воспользоваться, закинув свой процесс вне очереди.

---

### Алгоритм планирования - многоуровневые очереди
#### Идея
* Мы считаем, что должны быть внешне - задаваемые приоритеты выполнения процесса.
* Когда процесс рождается, мы спрашиваем у пользователя задать этому процессу приоритет.
* Мы разрешаем нескольким процессам иметь одинаковые уровни приоритетов
* Таким образом у нас появляются уровни приоритетов с определнным количеством приоритетов в них. 
  * Мы считаем, что внутри уровня приоритеты равны и мы можем использовать к ним алгоритм RoundRobin
  * Мы разрешаем выполняться процессам из определенной очереди только если нет других ожидающих процессов впереди

#### Проблемы
* Мы утыкаемся в дискретность шкалы приоритетов
* Если ставить приоритеты не так, то мы приводим к некорректному использованию ресурсов, что приведет к __неэффективности__
* У нас в очереди где-то глубоко может быть процесс, который все время будет перекрываться процессами более высоких уровней.

#### Решение проблемы голодающего процесса в алгоритме многоуровневой очереди
* Сделаем возможность лифта
* Сделает таймаут
* Если процесс по пистечении таймаута так и не перешел на выполнение, мы автоматически повышаем уровень его приоритета на единицу вверх, переводя в следующую очередь.
* Таким образом этот процесс может добраться вплоть до приоритета 1 уровня, и там ему будет отведет определенный квант времени. 
* После выделения процессорного времени, этот процесс будет помещен обратно в тот приоритет, который ему был поставлен изначально.
# Лекция 6
>В прошлой лекции мы познакомились с процессами в операционных системах.

## Управление процессами
---
## Состояния процесса
![img](images/lecture6/Снимок%20экрана%202020-10-28%20в%2013.19.37.png)
* Изначальнго нам достаточно 2 состояний:
  * Исполняется - испольщует ресурсы cpu
    * Процесс завершит свое исполнение
    * Процесс вернется в режим ожидания (например из-за таймера или ему потребюовалась операция ввода - вывода)
  * Ожидает
    * Перейдет в состояние исполнения

Когда процесс родился он попадлает в состяоние ожидания
Когда планировщик решит, что процессу нужно испольняться, он поставит его в режим исполнения.

* Проблема:
      * Мы не понимаем почему процесс находится в процессе ожидания
---
## Новая идея - испольщовать различные очереди для процесса кооторый будет находиться в ожидании и для процесса, который готов исполняться, но мы принудительно отправили его выжидать.
![img](images/lecture6/Снимок%20экрана%202020-10-28%20в%2013.21.24.png)
* Новое состяние - готовность
* Родившийся процесс попадет в состояние готовности, таким образом процесс не может начаться с операции ввода-вывода
* Мы образуем очередь из процессов готовых к выполнению
* Таким образом процесс в течении одной операции сможет успешно выполниться
---
* У нас есть 3 пути:
  *  Завершение процесса
  *  Процесс ожидает
  *  Процесс находится в состоянии готовности
> Такая модель реализуется любой операционной системой
---
## Как пошло дальнейшее развитие этих состояний ?
* Рождение - это процесс, который продолжителен во времени(копирование кода, смена идентификаторов, exec() и так далее...).
  * Таким образом появляется новое состояние, которое называется рождением.
* Завершение процесесса это точно так же достаточно длительный процесс в силу того, что он требует выполнения определенного количества операций(например если дочерний процесс завершается аварийно, то родитель должен получить сигнал от него и корректно завершить дочерний процесс, но родитель в этот момент может находиться в сосотоянии ожидания, что не позволить сделат это моментально)
  * Таким образом появляется состояние завершения
---
### В linux готовность и исполнение не разделяется между собой(состояние running - то есть готов или исполняется)
### Ожидание в linux делится на 2 варианта
![img](images/lecture6/Снимок%20экрана%202020-10-28%20в%2013.40.58.png)
* Ожидание не прерываемое
  * Например, когда нам нужно дождаться операции ввода - вывода
* Ожидание прерываемое
  * Например есть процесс веб сервер, он ожидает события, 
### Так же в linux реализован отдельный способ завершения процесса - процесс зомби
* Например родительский процесс должен считать сигнал SIGCHLD, который отправил ребенок, но родительский процесс находится в состоянии неприрываемого ожидания. Таким образом проходит какое-то время, и родтельский процесс не выходит из этого ожидания. Поэтому дочерний процесс остался и без родителся и не усыновился, потому что уже уничтожился. Таким образом этот процесс становится процессом зомби до тех пор, пока не перезагрузится операционная система. 

### В Linux выделяется отдельное состояние, называемое исключительной ситуацией. Exception.
![img](images/lecture6/Снимок%20экрана%202020-10-28%20в%2014.09.31.png)
> Таким образом, процесс можно поставить в состояние исключительной ситуации. В этом состоянии можно использовать разные алгоритмы по разрешению исключительных ситуаций. Если процесс не пытается исправиться, мы его завершаем

### В Linux есть состояние остановлен.
![img](images/lecture6/Снимок%20экрана%202020-10-28%20в%2014.08.54.png)
* Процесс может вызвать некое негодавание со стороны системного администраора. Пример, процесс начинает нерационально потреблять память. (У нас есть процесс с СУБД, у нас возникла блокировка, начинает расти очередь, память для очерди нарастает, память закончится и мы перейдем к свопингу. ). В такой ситуации мы погружаем процесс в ~~искуственную кому~~ состояние остановки.
* Такой процесс получается за счет принятия сигнала __SIGSTOP__
* Такой процесс не реагирует не на что кроме сигнала __SIGCONTINUE__
* Это состояние очень похоже на состояние исключительной ситуации.

---

## Новая тема - задача планирования
### А что мы понимаем под планированием ?
> Распределение времени процессоров между выполняющиммися заданиями или процессами одного или несолкьких пользователй
> Причем это процессорное время должно удовлетворять нескольким критериями:
  * Скорость выполнения
  * Время отклика

#### Планирование процессов сводится к дисциплине обслуживания некоторой очереди.
* У нас есть ядро
* У нас есть очередь
  * Возникают алгоритмы как из этой очереди выбирать процессы 
> В процессе эволюции все усложняется, очередей становится большей, и у нас появляется задача эффективно этими очередями управлять.

##### Есть набор процессов, которым мы должны предоставить ресурс, мы должны составить очередь из этих процессов. Время каждого из этих процессов - это разная величина. Система открытая, могут произойти события, которые поменяют конфигурацию системы, таким образом в момент планирования мы выстроили некий план, который выстроился от данных, которые были даны в начале составления плана. Но этот плане может быть некорректен относительно состояния конфигурации системы на данный момент. Таким образом, чем длиннее наш план в процессе составления, тем больше вероятность, что в процессе реализации этого плана что-то произойдет и это приведет к тому, что этот план будет не оптимальным или даже не исполнимым. 

* Таким образом есть несколько вариантов по уменьшению этой вероятности:
  * Как только мы выполним одно действие, сразу же прерываться, смотреть на состояния других процессов и менять их местами в очереди. 
    * Такой подход говорит о том, что у нас короткий горизонт планирования
      * Плюсы:
        * Мы очень точно можем контролировать состяние операционной системы
      * Минусы:
        * Принятие решения - это тоже трата ресурсов, таким образом эта стратегия достаточно затратна по времени процессора.
  * Один раз произвести планирование и составить очередь, по которой процессы будут исполняться последовательно.
    * Плюсы
      * Не сильно затратно по процессорному времени
    * Минусы
      * Есть вероятность, что наш план не будет оптимальным в процессе выполнения процессов.

> В разным операционных системах используются разные методы планирования
* Долгосрочное планирование
  * Оно находится между рождением и готовностью
  * Это принятие рещение о том, что этот процесс должен родиться
  * Тут используются алгоритмы, которые оценивают операционную систему на наличие ресурсов
* Среднесрочное планирование
  * Оно находится между переходами в ожидание в оперативной памяти
  * Ресурс оперативной памяти, подойдя к концу может привести к остановке всей системе
    * У нас есть процесс, который пошел в ожидание
    * Он находится в этом состоянии давно и не скоро получит сигнал
    * Мы можем скинуть страницы этого процесса в подчкачку
    * Таким образом мы улучшим состояние нашей системы глобально
* Коротко-срочное планирование
  * Оно находится между состояниями готовности процесса и его исполнения
  * Например раз в 200 секунд осуществляем перепланирование
* Так же есть выделение очередей ввода-вывода
  * Диски
  * Порты
  * Клавиатура
  * Мыши
  * И так далее...
  * Любое такое устройство получает свою очередь
  * Когда процесс попадает в состояние непрерываемого ожидания, он попадает в одну из очередей этих устройств. 
  * То есть пока мы не повзаимодействуем с одним из устройств, процесс будет находиться в состоянии непрерываемого ожидания

---

### Критерии планирования
1. Критерий справедливости - гарантировать каждому процессу равную долю процессорного времени 
2. Критерий эффективности - максимально эффективно использовать ресурсы(противоречие с 1 критерием)
3. Сокращение полного времени выполнения
   1. Мы хотим, чтобы полное время исполнения было минимальным
4. Сокращение ожидания
5. Сокращение времени отклика
   1. Важно для систем реального времени - то есть сделать так, чтобы выполнение задачи вошло в заданный промежуток времени
   2. Например, система звуко-аудио отклика)
### Свойства планирования
1. Предсказуемость
   1. Если мы многократно запустим на одних и тех же данных алгоритмы, результат должен быть +- одинаковым.
   2. Минимальные накладные расходы - минимальное использование ресурсов.
   3. Масштабируемость
      1. Система может быть на сервере 
      2. Система может быть на смартфоне
      3. Таким образом мы хотим, чтобы алгоритм работал одинаково хорошо на разных системах. 
# Лекция 10

## Семафоры и мьютексы

---

#### В чем минус программных алгоритмов, которые мы рассматривали на прошлой лекции ?
* Почти все операционные системы поддерживают конвейер команд
* Обмен данными проводится в самом простом варианте в виде передачи байтов
* Нам нужно синхронизировать работу этих процессов
  * То есть если у нас 1 процесс подал байт на ввод, то этот процесс не должен передавать новый байт до тех пор, пока другой процесс этот байт не прочитает
  * С другой стороны, если 2 процесс считал данные, то он должен перестать их считывать до тех пор, пока 1 процесс не пусти на ввод новые данные 
    * Если бы мы использовали обычный алгоритм в виде замка, то если команда 1 передала данные в переменную и открыла замок для команды 2
    * Команда 2 считала данные, перед этим закрыв замок для команды 1 на попытку записать туда что-то
    * После этого вновь открыла замок для команды 1
  * В таком случае нам постоянно нужно пошагово открывать и закрывать этот замок
  * Получается, что у нас бы происходила смена активного процесса
    * Меняем контекст
    * Переходим туда сюда из режима ядра
  * При таком подходе у нас будет очень нерациональное использование ресурсов

#### Подошли к идее использовать буфер
* Буфер - это фильтр, которые позволяет филировать неравномерность в работе команд
  * Теперь чтение и запись посходит из буфера

__В чем минус использования этого решения__
  1. Нельзя давать процессам возможность одновременно читать или записывать в буфер
      * Ведь при таком решении есть шанс, что процесс может прочитать данные, которые еще не до конца были записаны в буфер (__например при записи в буфер большого количества данных__)
      *  __Получается не консистентность данных__
  2. Надо предотвратить переполнение буфера
  3. Нужно предотвратить попытку чтения из пустого буфера

#### Для решения этих проблем был придуман Семафор
* Семафор - это целая и неотрицательная переменная
* Есть переменная семафор S
```
Semaphore S
```
* Мы разрешаем 2 операции 
```
P(S) : while S == 0 blocked;
    S = S - 1;
```
```
V(S): S = S + 1;
```
* Обе эти операции атомарны
* __Что тут важно__
  * Операция P(S):
    * Если семафор равен 0, то процесс не может получать доступ к ресурсу
    * Если семафор стал положительным, то мы убираем блокировку для процесса и одновременно уменьшаем на 1 семафор 
  * Операция V(S):
    * Если мы прекратили использование ресурса, то мы просто увеличиваем значение семафора на 1

#### Как это реально работает
* Рассмотрим решение задачи с буфером на примере использования семафоров
```
V(S): S = S + 1;

P(S) : while S == 0 blocked;
    S = S - 1;

Semaphore mutex = 1;
Semaphore empty = n; // n - количество элементов в буфере
Semaphore full = 0;

Producer() // функция для 1 процесса
{
    while(1)
    {
        produced_data; // блок полезных данных
        P(empty);
        P(mutex); // не пишет ли другой процесс
        put_data;
        V(mutex);
        V(full);
    }
}

Consumer() // функция для 2 процесса
{
    while(1)
    {
        P(full);
        P(mutex); // не пишет ли другой процесс
        get_data;
        V(mutex);
        V(empty);
        consume_data();
    }
}
```

##### Понятие mutex
* mutex - mutal exclusion - взаимоисключение 
* В чем разница ? Разница в реализации
* Есть 3 реализации
  * Spin lock --------------------------
    * В этой ситуации мы не переключаем контекст процесса
    * Эффективен, когда мы очень быстро меняем состоянии в критической секции
    * ----------------------------------------------- Вот тут не понял --------------------------------

#### Наследование приоритетов
* Если появился высокоприоритетный процесс, который стал требовать ресурс, мы должны низкоприоритетному процессу поднять приоритет до равенства с высокоприоритетным, чтобы они попали в 1 очередь
---
## Тупики
* Может быть такая ситуация
* ![img](images/lecture10/Screenshot%202021-01-13%20at%2015.25.37.png)
  * Процесс 1 должен для своей работы использовать ресурс 1 и ресурс 2, причем его код написан так, что его критические секции имеют пересечение
  * Процесс 2 должен для своей работы использовать ресурс 1 и ресурс 2, причем его код написан так, что его критические секции имеют пересечение
  * В начальный момент времени ресурс 1 и 2 были свободны, и оба процесса их захватили, в какой-то момент времени, процесс Р0 решил, что ему нужно взять ресурс 2, но сделать он этого не может, поэтому он просто остановил свою работу
  * Процесс Р1 пользовался ресурсом 2 и в какой-то момент решил использовать ресурс 1, но ресурс 1 занят процессом Р0, и этот процесс тоже остановил свою работу
  * Не один из этих процессов не может продолжить работу и не может отдать ресурс обратно
  * Таким образом мы получаем бесконечный тупик

#### Проблема обедающих философов
* Есть стол за котором сидят 5 философов
* Перед каждым стоит тарелка со спагетти
* Философ может есть спагетти только 2 вилками
* вилок на столе ровно 5
#### Решение проблемы обедающих философов
* Выделим несколько состояний для философов
  * Может размышлять
  * Может находиться в состоянии голодания
  * Может есть

1. Каждый берет левую потом правую вилку
   * Может получиться так, что все философы поднимут левую вилку одновременно, то произойдет тупик
2. Возьми левую вилку
   1. Попытайся взять правую
   2. Если правую взять не удалось, положи обратно левую
   3. После чего попробуй повторить
   4. Таким образом получается live - lock
3. Можно сделать так же как во 2 случае, но ждать рандомно перед тем, как повторять действия
   1. Таким образом нет никакой гарантии, что процессы не выберут одинаковое время и не попадут в live - lock или dead - lock
4. Наличие официанта
   1. Кто-то должен разрешать и запрещать есть этим философам

#### Условия возникновения тупиков
1. Mutual exclusion - условие взаимоисключения
2. Условие ожидания ресурсов - hold and wait
   1. Если процесс взял ресурс, он имеет право его не отдавать и при этом просить некоторые следующие ресурсы
3. Условия не перераспределяемости -  No Preemtion
   1. Если мы выделили процессу ресурс, то мы не можем забрать его обратно
4. Условие кругового ожидания - Circle wait
   1. Процессы относительно 2 или более ресурсов встали в кольцевое ожидание

#### Как решить проблему возникновения тупиков
1. Игнорировать проблему - так как вероятность возникновения тупика очень маленькая
2. Пытаться предотвратить тупики
   1. Сделать организацию ос таким образом, что вышеупомянутые 4 условия никогда не выполнятся одновременно
3. Обнаружение тупиков и восстанавливаем после них
   1. Обнаруживаем тупик после того как он произошел
   2. После этого за счет каких-то механизмов восстанавливаем работоспособность (механизмы эти рассматривать не будем)

__Таким образом поняли, что наиболее эффективно будет пытаться предотвратить тупики__
__Но как ?__
* Mutal exclusion
  * В некоторых ситуациях можно разрешать 2 процессам пользоваться 1 неразделяемым ресурсом
* Можно нарушить условие hold and wait
  * Мы разрешаем процессу только в самом начале или когда он 1 раз просит тот или иной ресурс, сразу же просить все ресурсы от него
    * И либо даем ему все ресурсы сразу
    * Либо отказываем в даче ресурсов
  * Это можно использовать там, где не очень большое количество ресурсов
* Можно нарушить принцип отсутствия перераспределения
  * По какому-то принципу отбирать недостойный процесс и забирать у него ресурс, предварительно забуферизовав этот ресурс
  * Прямо как при прерывании
* Можно попытаться нарушить круговое ожидание
  * Можно пронумеровать все ресурсы
  * Мы разрешаем процессу брать ресурс только с номером, который выше чем номер самого ресурса

##### Проблема читателей и писателей
```
P0 -----(r)     --------(r)
P1      -------(r)
P2   ----(w)-------(w)
```

* Проблема в том, что процесс записи может уйти в вечное голодание из-за того, что постоянно будут появляться новые процессы на чтение
* __Решение__
  * Уложим требования на запись и чтение в очередь